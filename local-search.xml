<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>方法1 查询自己使用的Python版本</title>
    <link href="/2025/12/03/%E7%AC%AC1%E6%9D%A1_%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E7%9A%84Python%E7%89%88%E6%9C%AC/"/>
    <url>/2025/12/03/%E7%AC%AC1%E6%9D%A1_%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E7%9A%84Python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自《Effective Python（第 2 版）》第 1 条的内容，并在此基础上做了更细致的技术展开，帮助你<strong>系统掌握如何确认自己正在使用哪一个 Python 版本</strong>。</p></blockquote><hr><h2 id="一、为什么必须先搞清楚-Python-版本？"><a href="#一、为什么必须先搞清楚-Python-版本？" class="headerlink" title="一、为什么必须先搞清楚 Python 版本？"></a>一、为什么必须先搞清楚 Python 版本？</h2><p>写 Python 代码之前，第一件事不是安装库，也不是敲下第一行 <code>print(&quot;Hello, world&quot;)</code>，而是 <strong>搞清楚自己到底在用哪个 Python 版本</strong>。原因主要有：</p><ol><li><p><strong>语法特性不同</strong>  </p><ul><li>Python 2 与 Python 3 在打印、整除、字符串编码等语法上都有差异。  </li><li>即使都是 Python 3，不同小版本也可能引入新语法或标准库能力（例如 3.6 的 f-string，3.8 的海象运算符 <code>:=</code>）。</li></ul></li><li><p><strong>第三方库兼容性不同</strong><br>很多库会写明：<code>Requires Python &gt;= 3.8</code> 或 <code>Python 3.7+ only</code>。如果版本不符，装库、运行都会报错。</p></li><li><p><strong>运行环境可能装了多个版本</strong><br>同一台机器上经常同时存在：</p><ul><li>系统自带的 Python（可能是 2.7）  </li><li>用户自己安装的 Python 3.7 &#x2F; 3.8 &#x2F; 3.10 ……<br><strong>命令行中的 <code>python</code>、<code>python3</code> 究竟指向哪一个，不问清楚容易“踩坑”。</strong></li></ul></li><li><p><strong>Python 2 已经停止维护</strong><br>官方在 <strong>2020 年 1 月 1 日</strong> 正式停止了对 Python 2 的支持（停止修复 bug、安全漏洞和新增特性）。  </p><ul><li>新项目强烈建议统一使用 <strong>Python 3</strong>。  </li><li>继续依赖 Python 2 只会在未来维护中不断“吃亏”。</li></ul></li></ol><p>因此，“查询当前 Python 版本” 是一切 Python 工作的第一条建议，也就是本条要讲的全部内容。</p><hr><h2 id="二、在命令行中查看-Python-版本"><a href="#二、在命令行中查看-Python-版本" class="headerlink" title="二、在命令行中查看 Python 版本"></a>二、在命令行中查看 Python 版本</h2><h3 id="1-最常用的-version"><a href="#1-最常用的-version" class="headerlink" title="1. 最常用的 --version"></a>1. 最常用的 <code>--version</code></h3><p>打开终端或命令提示符，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python --version<br>Python 2.7.10<br></code></pre></td></tr></table></figure><ul><li>这行输出表示：当前 <code>python</code> 命令对应的解释器是 <strong>Python 2.7.10</strong>。  </li><li>在很多类 Unix 系统（如某些 Linux 发行版、旧版 macOS）中，<code>python</code> 往往是 <strong>系统自带的 Python 2.7</strong>，便于兼容旧脚本。</li></ul><p>如果你的目标是使用 <strong>Python 3</strong>，但 <code>python --version</code> 显示的是 2.x，这就意味着：</p><ul><li>要么你的环境变量把 Python 2 放在了前面；  </li><li>要么系统默认就把 <code>python</code> 当成 Python 2 来用。</li></ul><p>这时，你通常可以使用下面的命令。</p><h3 id="2-使用-python3-version"><a href="#2-使用-python3-version" class="headerlink" title="2. 使用 python3 --version"></a>2. 使用 <code>python3 --version</code></h3><p>在同一台机器上，常常同时安装有 Python 2 和 Python 3。于是就有了通常的约定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3 --version<br>Python 3.8.0<br></code></pre></td></tr></table></figure><ul><li><p>在很多 Linux &#x2F; macOS 系统中：  </p><ul><li><code>python</code> → Python 2.x  </li><li><code>python3</code> → Python 3.x</li></ul></li><li><p>在 Windows 上，如果你使用官方安装包或 Microsoft Store 安装 Python 3，<code>python</code> 和 <code>py</code> 启动器的行为可能略有不同：  </p><ul><li><code>python</code> 可能指向最新安装的版本；  </li><li><code>py -3</code> 明确表示选择 Python 3。</li></ul></li></ul><blockquote><p>实战建议：  </p><ul><li>如果你看到 <code>python --version</code> 显示的是 2.x，而你打算编写的是 Python 3 代码，从现在开始请习惯使用 <strong><code>python3</code></strong> 或对应的版本启动器（如 <code>py -3</code>）。</li></ul></blockquote><h3 id="3-为什么版本号要记清楚？"><a href="#3-为什么版本号要记清楚？" class="headerlink" title="3. 为什么版本号要记清楚？"></a>3. 为什么版本号要记清楚？</h3><p>书中举了两个版本作为例子：</p><ul><li><strong>Python 3.7</strong>：本书大部分示例遵循的语法版本（发布于 2018 年 6 月）。  </li><li><strong>Python 3.8</strong>：书中个别示例使用了 3.8 引入的新特性（发布于 2019 年 10 月）。</li></ul><p>在阅读书籍、博客或使用框架时，对方经常会写明“基于 Python 3.7+”，这不是废话，而是告诉你：</p><ul><li>只要你的版本 <strong>不低于</strong> 这个要求，示例基本可以直接运行。  </li><li>如果你还停留在 Python 2，就会遇到各种语法错误、库安装失败等问题。</li></ul><hr><h2 id="三、在-Python-代码中查询版本：sys-version-info"><a href="#三、在-Python-代码中查询版本：sys-version-info" class="headerlink" title="三、在 Python 代码中查询版本：sys.version_info"></a>三、在 Python 代码中查询版本：<code>sys.version_info</code></h2><p>仅仅知道命令行里的 <code>python</code> 是几，很多时候还不够。更好的方式是在<strong>程序内部</strong>直接读取当前解释器的版本信息。</p><h3 id="1-使用-sys-version-info"><a href="#1-使用-sys-version-info" class="headerlink" title="1. 使用 sys.version_info"></a>1. 使用 <code>sys.version_info</code></h3><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">print</span>(sys.version_info)<br><span class="hljs-built_in">print</span>(sys.version)<br></code></pre></td></tr></table></figure><p>在类似 Python 3.8 的环境下，可能得到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">sys.version_info(major=3, minor=8, micro=0, releaselevel=&#x27;final&#x27;, serial=0)<br>3.8.0 (default, Oct 21 2019, 12:51:32) <br>[Clang 6.0 (clang-600.0.57)]<br></code></pre></td></tr></table></figure><p>解释一下：</p><ul><li><code>major</code>：主版本号（这里是 <code>3</code>，表示 Python 3 系列）。  </li><li><code>minor</code>：次版本号（这里是 <code>8</code>，表示 3.8）。  </li><li><code>micro</code>：补丁版本号（0 表示 3.8.0）。  </li><li><code>releaselevel</code>：发行级别，通常为 <code>&#39;alpha&#39;</code>、<code>&#39;beta&#39;</code>、<code>&#39;candidate&#39;</code> 或 <code>&#39;final&#39;</code>。  </li><li><code>serial</code>：发行序号，一般用于内部区分不同的预发行版本。</li></ul><p><code>sys.version</code> 则是一个<strong>可读性更高的字符串</strong>，附带了编译时间和编译器信息。</p><h3 id="2-根据版本做条件判断"><a href="#2-根据版本做条件判断" class="headerlink" title="2. 根据版本做条件判断"></a>2. 根据版本做条件判断</h3><p>在库开发或要兼容多版本 Python 时，你可以据此写出版本分支逻辑，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">if</span> sys.version_info &lt; (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;This project requires Python 3.7 or higher&quot;</span>)<br><br><span class="hljs-comment"># 或者判断某个特性是否可用</span><br><span class="hljs-keyword">if</span> sys.version_info &gt;= (<span class="hljs-number">3</span>, <span class="hljs-number">8</span>):<br>    <span class="hljs-comment"># 使用 3.8 引入的新特性</span><br>    <span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> metadata<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 使用兼容写法或第三方 backport</span><br>    <span class="hljs-keyword">import</span> importlib_metadata <span class="hljs-keyword">as</span> metadata<br></code></pre></td></tr></table></figure><p>这样即可让脚本在不符合要求的解释器上 <strong>尽早失败</strong>，而不是等到运行到某行语法时报错。</p><hr><h2 id="四、Python-2-的“退役”与迁移建议"><a href="#四、Python-2-的“退役”与迁移建议" class="headerlink" title="四、Python 2 的“退役”与迁移建议"></a>四、Python 2 的“退役”与迁移建议</h2><p>书中提到，Python 2 已在 <strong>2020 年 1 月 1 日</strong> 之后正式停止维护：</p><ul><li>不再修复新发现的 bug；  </li><li>不再发布安全补丁；  </li><li>不再添加任何新特性。</li></ul><p>如果你所在的项目依旧在使用 Python 2，将面临：</p><ol><li><strong>安全风险</strong>：新漏洞不会被官方修补。  </li><li><strong>生态逐渐萎缩</strong>：越来越多库停止对 Python 2 的支持。  </li><li><strong>开发者成本高</strong>：新加入的同学大都只学过 Python 3，需要花额外时间理解旧语法和兼容性问题。</li></ol><p>因此：</p><ul><li><strong>新项目</strong>：务必使用 Python 3（现代环境建议 3.10+，书中以 3.7&#x2F;3.8 为例）。  </li><li><strong>旧项目</strong>：<ul><li>可借助 <code>2to3</code> 工具进行代码初步迁移；  </li><li>结合 <code>six</code> 等兼容库，逐步过渡到 Python 3；  </li><li>避免新增只支持 Python 2 的代码，逐步减少技术债。</li></ul></li></ul><hr><h2 id="五、实战小结与建议"><a href="#五、实战小结与建议" class="headerlink" title="五、实战小结与建议"></a>五、实战小结与建议</h2><p>结合本条内容，可以形成以下“最小实践 checklist”：</p><ol><li><p><strong>先查版本再写代码</strong></p><ul><li>在终端中执行：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python --version<br>python3 --version<br></code></pre></td></tr></table></figure></li><li>搞清楚当前默认解释器到底是 Python 2 还是 Python 3。</li></ul></li><li><p><strong>确保新项目运行在 Python 3 上</strong></p><ul><li>如果 <code>python</code> 是 2.x，优先使用 <code>python3</code> 或 <code>py -3</code> 来运行你的脚本。  </li><li>安装依赖时也使用对应的 <code>pip3</code>（或虚拟环境中的 <code>pip</code>）。</li></ul></li><li><p><strong>在代码中显式检查版本</strong></p><ul><li>使用 <code>sys.version_info</code> 判断：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">assert</span> sys.version_info &gt;= (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>), <span class="hljs-string">&quot;Need Python 3.7 or later&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>尽快告别 Python 2</strong></p><ul><li>若公司或项目中仍有 Python 2 代码，建议制定迁移计划：  <ul><li>优先把关键服务迁移到 Python 3；  </li><li>用 <code>2to3</code> 做基础转换；  </li><li>使用 <code>six</code> 等库在过渡期同时兼容。</li></ul></li></ul></li></ol><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>第 1 条看起来只是一个简单的“版本检查”小技巧，但它体现了 <strong>Pythonic 思维</strong> 中的重要一环：</p><blockquote><p>在动手写代码之前，先把环境、工具和前提条件搞清楚。</p></blockquote><p>确认自己使用的 Python 版本，是写好 Python 代码的第一步，也是后续一切“高质量 Python 编程”的基础。只要养成这个习惯，你在阅读书籍、博客、文档和使用第三方库时，就能迅速判断：<strong>“这段代码，我的环境跑得起来吗？”</strong> —— 从而少踩很多不必要的坑。</p>]]></content>
    
    
    <categories>
      
      <category>Pythonic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python Pythonic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第 5 条：用辅助函数取代复杂的表达式</title>
    <link href="/2025/12/03/%E7%AC%AC5%E6%9D%A1_%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2025/12/03/%E7%AC%AC5%E6%9D%A1_%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自《Effective Python（第 2 版）》第 5 条“用辅助函数取代复杂的表达式”，并在此基础上做了扩展。<br>核心思想：<strong>当一行表达式变得又长又绕时，与其拼命堆逻辑，不如果断抽成一个辅助函数。</strong></p></blockquote><hr><h2 id="一、问题背景：Python-的表达式“太灵活”了"><a href="#一、问题背景：Python-的表达式“太灵活”了" class="headerlink" title="一、问题背景：Python 的表达式“太灵活”了"></a>一、问题背景：Python 的表达式“太灵活”了</h2><p>Python 提供了很多非常方便的语言特性：</p><ul><li><code>and</code> &#x2F; <code>or</code> 的短路求值；</li><li>各种对象的“真值”语义（空字符串、空列表、0、<code>None</code> 都会被判定为 <code>False</code>）；</li><li>条件表达式：<code>a if condition else b</code>；</li><li>字典的 <code>.get()</code> 方法可以设置默认值。</li></ul><p>这些特性本来是为了让代码写起来更简洁，但如果滥用，就容易出现下面这种“挤成一行”的复杂表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">value = parse_qs(query).get(<span class="hljs-string">&#x27;red&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>这行表达式里同时夹杂了：函数调用、字典访问、列表索引、布尔运算以及默认值处理；</li><li>刚写出来的时候你能看懂，三天之后连自己都要读半天。</li></ul><p>书中通过一个 <strong>解析 URL 查询参数</strong> 的例子，来说明如何用辅助函数让逻辑变得更清晰。</p><hr><h2 id="二、示例：解析-URL-查询字符串"><a href="#二、示例：解析-URL-查询字符串" class="headerlink" title="二、示例：解析 URL 查询字符串"></a>二、示例：解析 URL 查询字符串</h2><p>假设我们要解析这样的 URL 查询字符串：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">red=5&amp;blue=0&amp;green=<br></code></pre></td></tr></table></figure><p>用 <code>urllib.parse.parse_qs</code> 可以得到一个“值为列表”的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> parse_qs<br><br>my_values = parse_qs(<span class="hljs-string">&#x27;red=5&amp;blue=0&amp;green=&#x27;</span>, keep_blank_values=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(my_values))<br><span class="hljs-comment"># &#123;&#x27;red&#x27;: [&#x27;5&#x27;], &#x27;blue&#x27;: [&#x27;0&#x27;], &#x27;green&#x27;: [&#x27;&#x27;]&#125;</span><br></code></pre></td></tr></table></figure><p>这个字典有几个特点：</p><ul><li>每个 key 对应的 value <strong>都是一个列表</strong>，因为同一个参数可以在 URL 里出现多次；</li><li>不存在的 key 根本不会出现在字典中；</li><li>使用 <code>keep_blank_values=True</code> 之后，即便参数值为空字符串也会被保留（如 <code>&#39;green&#39;: [&#39;&#39;]</code>）。</li></ul><p>现在问题来了：<strong>如何安全、优雅地取出 <code>red</code>、<code>green</code>、<code>opacity</code> 这些参数的整数值？</strong></p><hr><h2 id="三、第一版：用布尔表达式“硬凑”的写法"><a href="#三、第一版：用布尔表达式“硬凑”的写法" class="headerlink" title="三、第一版：用布尔表达式“硬凑”的写法"></a>三、第一版：用布尔表达式“硬凑”的写法</h2><p>书中首先给出了一个“一行流”的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">red = my_values.get(<span class="hljs-string">&#x27;red&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>green = my_values.get(<span class="hljs-string">&#x27;green&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>opacity = my_values.get(<span class="hljs-string">&#x27;opacity&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这一行看起来很“Pythonic”，但拆开来其实干了好几件事：</p><ol><li><p><code>my_values.get(&#39;red&#39;, [&#39;&#39;])</code>：</p><ul><li>如果有 <code>&#39;red&#39;</code>，返回类似 <code>[&#39;5&#39;]</code> 的列表；</li><li>如果没有，则返回默认值 <code>[&#39;&#39;]</code>。</li></ul></li><li><p><code>[0]</code>：取出列表里的第一个元素（要么是 <code>&#39;5&#39;</code>，要么是空字符串 <code>&#39;&#39;</code>）。</p></li><li><p><code>or 0</code>：</p><ul><li>如果前面的值在布尔上下文中为真，则返回该值；  </li><li>否则返回 <code>0</code>；</li><li>利用的是 Python 中空字符串为 <code>False</code> 的特性。</li></ul></li></ol><p>整体等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">first_value = my_values.get(<span class="hljs-string">&#x27;red&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> first_value:<br>    red = first_value<br><span class="hljs-keyword">else</span>:<br>    red = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="这段代码的问题"><a href="#这段代码的问题" class="headerlink" title="这段代码的问题"></a>这段代码的问题</h3><ul><li><strong>语义不直观</strong>：你需要非常熟悉 <code>.get()</code>、真值规则和 <code>or</code> 的短路行为，才能快速看明白。  </li><li><strong>缺乏类型感</strong>：最终我们想要的是整数，但这行代码返回的是字符串 <code>&#39;5&#39;</code> 或 <code>0</code>，显得有点“型不对题”。  </li><li><strong>重复性强</strong>：<code>red</code>、<code>green</code>、<code>opacity</code> 三行几乎一样，但复制粘贴又显得不够优雅。</li></ul><hr><h2 id="四、第二版：用-if-else-展开逻辑"><a href="#四、第二版：用-if-else-展开逻辑" class="headerlink" title="四、第二版：用 if/else 展开逻辑"></a>四、第二版：用 <code>if/else</code> 展开逻辑</h2><p>为了提高可读性，我们可以先不用花里胡哨的 <code>or</code> 写法，而是老老实实写出 <code>if/else</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">red = my_values.get(<span class="hljs-string">&#x27;red&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])<br><span class="hljs-keyword">if</span> red[<span class="hljs-number">0</span>]:<br>    red = <span class="hljs-built_in">int</span>(red[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">else</span>:<br>    red = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>这段代码一眼就能看出意图：<ul><li>先尝试取出第一个值；</li><li>如果非空，就把它转成 <code>int</code>；</li><li>否则使用默认值 <code>0</code>。</li></ul></li></ul><p>如果对 <code>green</code>、<code>opacity</code> 也这样写，就需要重复三遍类似的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">green = my_values.get(<span class="hljs-string">&#x27;green&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])<br><span class="hljs-keyword">if</span> green[<span class="hljs-number">0</span>]:<br>    green = <span class="hljs-built_in">int</span>(green[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">else</span>:<br>    green = <span class="hljs-number">0</span><br><br>opacity = my_values.get(<span class="hljs-string">&#x27;opacity&#x27;</span>, [<span class="hljs-string">&#x27;&#x27;</span>])<br><span class="hljs-keyword">if</span> opacity[<span class="hljs-number">0</span>]:<br>    opacity = <span class="hljs-built_in">int</span>(opacity[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">else</span>:<br>    opacity = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可读性提升了，但缺点也明显：</p><ul><li><strong>冗余</strong>：同样的结构重复多次；</li><li>不利于后期维护（如果规则变了，得改三处）。</li></ul><p>这时候，就轮到“辅助函数”登场了。</p><hr><h2 id="五、第三版：抽出辅助函数-get-first-int"><a href="#五、第三版：抽出辅助函数-get-first-int" class="headerlink" title="五、第三版：抽出辅助函数 get_first_int"></a>五、第三版：抽出辅助函数 <code>get_first_int</code></h2><p>书中给出的做法是，把“从 <code>my_values</code> 中安全取得整数值”的逻辑提炼成一个辅助函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_first_int</span>(<span class="hljs-params">values, key, default=<span class="hljs-number">0</span></span>):<br>    found = values.get(key, [<span class="hljs-string">&#x27;&#x27;</span>])<br>    <span class="hljs-keyword">if</span> found[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(found[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> default<br></code></pre></td></tr></table></figure><p>然后我们就可以在主逻辑中这样调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">red = get_first_int(my_values, <span class="hljs-string">&#x27;red&#x27;</span>)<br>green = get_first_int(my_values, <span class="hljs-string">&#x27;green&#x27;</span>)<br>opacity = get_first_int(my_values, <span class="hljs-string">&#x27;opacity&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="这样做有什么好处？"><a href="#这样做有什么好处？" class="headerlink" title="这样做有什么好处？"></a>这样做有什么好处？</h3><ol><li><p><strong>语义清晰</strong>  </p><ul><li>函数名 <code>get_first_int</code> 已经把意图说明白了：<ul><li>“从 values 中取 key 对应的第一个值，并转成 int，如果缺失或为空则返回默认”。</li></ul></li></ul></li><li><p><strong>调用处非常简洁</strong>  </p><ul><li>主逻辑只剩下三行简单的赋值语句，每一行都是“领域语言”：<ul><li>“<code>red</code> 是 <code>my_values</code> 里的第一个整型值，没有就用默认值”。</li></ul></li></ul></li><li><p><strong>便于测试和复用</strong>  </p><ul><li>辅助函数可以单独写单元测试，覆盖各种边界情况；  </li><li>将来如果有其他查询参数也需要类似逻辑，直接复用。</li></ul></li><li><p><strong>遵循 DRY 原则（Don’t Repeat Yourself）</strong>  </p><ul><li>把重复的结构放进一个函数中维护，只在必要时更改一处即可。</li></ul></li></ol><h3 id="可进一步小改进的小点"><a href="#可进一步小改进的小点" class="headerlink" title="可进一步小改进的小点"></a>可进一步小改进的小点</h3><p>根据个人口味，你还可以对 <code>get_first_int</code> 做一些小优化，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Mapping, <span class="hljs-type">Sequence</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_first_int</span>(<span class="hljs-params">values: Mapping[<span class="hljs-built_in">str</span>, <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>]],</span><br><span class="hljs-params">                  key: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">                  default: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    found = values.get(key)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:          <span class="hljs-comment"># None 或 空列表 都视为 False</span><br>        <span class="hljs-keyword">return</span> default<br>    first = found[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(first) <span class="hljs-keyword">if</span> first <span class="hljs-keyword">else</span> default<br></code></pre></td></tr></table></figure><ul><li>使用类型注解，让 IDE 和静态检查工具更好地理解这个函数；</li><li>利用“空列表为 False”的特性，使得对 <code>None</code> 和 <code>[]</code> 的处理更统一。</li></ul><hr><h2 id="六、辅助函数的设计思路：什么时候该“抽出来”？"><a href="#六、辅助函数的设计思路：什么时候该“抽出来”？" class="headerlink" title="六、辅助函数的设计思路：什么时候该“抽出来”？"></a>六、辅助函数的设计思路：什么时候该“抽出来”？</h2><p>围绕本条的例子，我们可以总结出几个判断标准：</p><ol><li><p><strong>一行表达式包含两种以上逻辑</strong>  </p><ul><li>例如：数据获取 + 类型转换 + 默认值处理 + 容错逻辑；  </li><li>这种情况下，更应该用一个函数来体现“这件事”的语义，而不是堆在一行表达式里。</li></ul></li><li><p><strong>同样的逻辑在代码中出现了两次以上</strong>  </p><ul><li>关注重复；  </li><li>一旦发现多处有着相同或高度相似的表达式，就应该考虑抽成辅助函数。</li></ul></li><li><p><strong>这段逻辑本身具有业务意义</strong>  </p><ul><li>比如“获取查询参数的第一个整数值”；  </li><li>把逻辑提炼成有意义的函数名，有助于让代码更接近业务语言。</li></ul></li><li><p><strong>你需要为这段逻辑写单元测试</strong>  </p><ul><li>复杂表达式难以单独测试，辅助函数则可以直接针对不同输入写多组测试用例。</li></ul></li></ol><blockquote><p>一个经验法则：<br>当你在 review 自己代码时，发现 <strong>“要读懂这一行，得在脑子里执行好几步”</strong>，那就说明该把它变成一个函数了。</p></blockquote><hr><h2 id="七、要点总结与实践清单"><a href="#七、要点总结与实践清单" class="headerlink" title="七、要点总结与实践清单"></a>七、要点总结与实践清单</h2><p>书中在最后给出了几条要点，我们可以在此基础上扩展成一份 checklist：</p><ol><li><p><strong>避免一行里塞太多逻辑</strong></p><ul><li>尽量不要把 <code>.get()</code>、索引、<code>or</code>、<code>int()</code> 等操作连成一串；</li><li>多步逻辑宁可拆成几行，也不要牺牲可读性。</li></ul></li><li><p><strong>用 <code>if/else</code> 代替过于“聪明”的布尔表达式</strong></p><ul><li><code>a or b</code>、<code>a and b</code> 在简单场景很好用；  </li><li>当逻辑稍微复杂时，就应考虑改为显式的 <code>if/else</code>。</li></ul></li><li><p><strong>识别可以通用的模式，抽出辅助函数</strong></p><ul><li>只做一件事；  </li><li>函数名清晰描述“这件事”是什么；  </li><li>接口保持通用性（如接受 dict、返回 int）。</li></ul></li><li><p><strong>遵循 DRY 原则</strong></p><ul><li>相似逻辑不要散落在代码各处；  </li><li>一旦需求变更，只用修改辅助函数即可。</li></ul></li><li><p><strong>实践建议：在项目中使用下面的 workflow</strong></p><ul><li><input disabled="" type="checkbox"> 写出最直观、可能比较冗长的版本（多行 <code>if/else</code>）；  </li><li><input disabled="" type="checkbox"> 提炼出重复逻辑，抽成一个或多个辅助函数；  </li><li><input disabled="" type="checkbox"> 用辅助函数简化调用处代码；  </li><li><input disabled="" type="checkbox"> 为辅助函数写测试；  </li><li><input disabled="" type="checkbox"> 删除不再需要的复杂表达式。</li></ul></li></ol><p>当你养成“<strong>用辅助函数取代表达式堆砌</strong>”的习惯后，你的 Python 代码会变得更易读、更易测、更易维护。这也是 Pythonic 思维中非常重要的一环：<strong>可读性与简单性永远优先于“炫技”。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Pythonic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python Pythonic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/02/hello-world/"/>
    <url>/2025/12/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】从零彻底搞懂 KMP 字符串匹配算法（含最清晰讲解与代码）</title>
    <link href="/2025/12/02/kmp-algorithm/"/>
    <url>/2025/12/02/kmp-algorithm/</url>
    
    <content type="html"><![CDATA[<p>在字符串匹配中，我们常常需要在一个长字符串 <code>haystack</code> 中查找某个模式串 <code>needle</code> 是否出现。最直观的方法是暴力匹配（Brute Force），但它的最坏时间复杂度是 <strong>O(n × m)</strong>。<br>为了优化匹配效率，KMP（Knuth–Morris–Pratt）算法应运而生，它能让匹配过程时间复杂度降为 <strong>O(n + m)</strong>。</p><p>本文将从“为什么需要 KMP”开始，一步步解释 next 数组（也称 lps 数组）的含义、构建过程，并补充最清晰的代码实现。</p><hr><h1 id="🎯-1-为什么需要-KMP？"><a href="#🎯-1-为什么需要-KMP？" class="headerlink" title="🎯 1. 为什么需要 KMP？"></a>🎯 1. 为什么需要 KMP？</h1><p>暴力匹配示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">haystack</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aabaaac&quot;</span><br><span class="hljs-attribute">needle</span>   <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaac&quot;</span><br></code></pre></td></tr></table></figure><p>当匹配失败时，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">c</span><br>| | |<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">c</span><br></code></pre></td></tr></table></figure><p>暴力法会把模式串整个向右移动一位，重新匹配。</p><p>但我们明明已经匹配出了前两个字符 <code>&quot;aa&quot;</code>，模式串多多少少应该利用这个信息，而不是全部重新开始。</p><p>KMP 的核心思想就是：</p><blockquote><p>❗当匹配失败时，根据前缀和后缀的公共部分，计算下一个应该匹配的位置。</p></blockquote><p>这就是 <strong>next（最长公共前后缀）数组</strong> 的作用。</p><hr><h1 id="🎯-2-什么是-next（lps）数组？"><a href="#🎯-2-什么是-next（lps）数组？" class="headerlink" title="🎯 2. 什么是 next（lps）数组？"></a>🎯 2. 什么是 next（lps）数组？</h1><p><code>next[i]</code> 表示：</p><blockquote><p><strong>模式串 s[0…i] 的最长相等的前缀与后缀的长度。</strong></p></blockquote><p>例如模式串：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ababaca&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>i</th><th>s[i]</th><th>前缀</th><th>后缀</th><th>最长相同长度 next[i]</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>-</td><td>-</td><td>0</td></tr><tr><td>1</td><td>b</td><td>a</td><td>b</td><td>0</td></tr><tr><td>2</td><td>a</td><td>a,ab</td><td>ba,a</td><td>1</td></tr><tr><td>3</td><td>b</td><td>ab,aba</td><td>bab,ab</td><td>2</td></tr><tr><td>4</td><td>a</td><td>…</td><td>…</td><td>3</td></tr><tr><td>5</td><td>c</td><td>…</td><td>…</td><td>0</td></tr><tr><td>6</td><td>a</td><td>…</td><td>…</td><td>1</td></tr></tbody></table><p>next 数组就是建立在“前缀 &#x3D; 后缀”的原理之上，用来指导匹配失败后模式串应该跳到哪里。</p><hr><h1 id="🎯-3-next-数组的构造过程（最关键的位置）"><a href="#🎯-3-next-数组的构造过程（最关键的位置）" class="headerlink" title="🎯 3. next 数组的构造过程（最关键的位置）"></a>🎯 3. next 数组的构造过程（最关键的位置）</h1><p>我们构造 next 数组时，用两个指针：</p><ul><li><code>i</code>：当前处理的位置  </li><li><code>j</code>：当前最长前后缀长度</li></ul><p>构造逻辑：</p><ol><li>如果 <code>s[i] == s[j]</code> → 两者继续延长  </li><li>如果失败（<code>s[i] != s[j]</code>）<br>→ j 应该回退到 <code>next[j-1]</code>（更短但可能匹配的前后缀）</li></ol><p>这就是为什么回退写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">j = <span class="hljs-built_in">next</span>[j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><hr><h1 id="🧠-4-最清晰的-KMP-Python-实现（含注释）"><a href="#🧠-4-最清晰的-KMP-Python-实现（含注释）" class="headerlink" title="🧠 4. 最清晰的 KMP Python 实现（含注释）"></a>🧠 4. 最清晰的 KMP Python 实现（含注释）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 构造 next (lps) 数组</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getNext</span>(<span class="hljs-params">self, <span class="hljs-built_in">next</span>: <span class="hljs-built_in">list</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        j = <span class="hljs-number">0</span>             <span class="hljs-comment"># j 表示前后缀相等的长度</span><br>        <span class="hljs-built_in">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>       <span class="hljs-comment"># 单字符没有前后缀</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 1. 匹配失败 → 回退 j</span><br>            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i] != s[j]:<br>                j = <span class="hljs-built_in">next</span>[j - <span class="hljs-number">1</span>]<br><br>            <span class="hljs-comment"># 2. 匹配成功 → j++</span><br>            <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                j += <span class="hljs-number">1</span><br><br>            <span class="hljs-built_in">next</span>[i] = j   <span class="hljs-comment"># 记录最长公共前后缀长度</span><br><br>    <span class="hljs-comment"># KMP 主匹配过程</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack: <span class="hljs-built_in">str</span>, needle: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(needle) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 1. 生成 next 数组</span><br>        <span class="hljs-built_in">next</span> = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(needle)<br>        <span class="hljs-variable language_">self</span>.getNext(<span class="hljs-built_in">next</span>, needle)<br><br>        j = <span class="hljs-number">0</span>  <span class="hljs-comment"># needle 的指针</span><br><br>        <span class="hljs-comment"># 2. 开始匹配 haystack</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-comment"># 匹配失败 → 回退 j</span><br>            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> haystack[i] != needle[j]:<br>                j = <span class="hljs-built_in">next</span>[j - <span class="hljs-number">1</span>]<br><br>            <span class="hljs-comment"># 匹配成功 → j 往前走</span><br>            <span class="hljs-keyword">if</span> haystack[i] == needle[j]:<br>                j += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 完全匹配</span><br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle):<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-built_in">len</span>(needle) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h1 id="🎯-5-为什么匹配失败要写成-j-next-j-1-？"><a href="#🎯-5-为什么匹配失败要写成-j-next-j-1-？" class="headerlink" title="🎯 5. 为什么匹配失败要写成 j = next[j-1]？"></a>🎯 5. 为什么匹配失败要写成 <code>j = next[j-1]</code>？</h1><p>这是很多初学者最困惑的地方。</p><p>假设已经匹配：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c<br>      ↑ mismatch<br></code></pre></td></tr></table></figure><p>此时已知 <code>&quot;abab&quot;</code> 中最长公共前后缀长度为 2（<code>&quot;ab&quot;</code>）。</p><p>所以下一步不应该从 0 开始，而应该从 <code>&quot;ab&quot;</code> 之后继续：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br>    <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> c<br>    ↑ 从这里继续<br></code></pre></td></tr></table></figure><p>这就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">j = <span class="hljs-built_in">next</span>[j-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>这一步的意义。</p><hr><h1 id="🎯-6-KMP-的时间复杂度"><a href="#🎯-6-KMP-的时间复杂度" class="headerlink" title="🎯 6. KMP 的时间复杂度"></a>🎯 6. KMP 的时间复杂度</h1><table><thead><tr><th>操作</th><th>复杂度</th></tr></thead><tbody><tr><td>构造 next 数组</td><td>O(m)</td></tr><tr><td>匹配过程</td><td>O(n)</td></tr><tr><td><strong>总复杂度</strong></td><td><strong>O(n + m)</strong></td></tr></tbody></table><p>比暴力匹配 O(n × m) 大大优化。</p><hr><h1 id="🎉-总结"><a href="#🎉-总结" class="headerlink" title="🎉 总结"></a>🎉 总结</h1><p>KMP 是字符串匹配领域的经典算法，它通过 next 数组记录前缀与后缀的重叠关系，使匹配失败时能快速跳转，从而达到线性时间复杂度。</p><p>本文通过：</p><ul><li>为什么需要 KMP  </li><li>next 数组的意义  </li><li>如何构造 next  </li><li>Python 完整实现  </li><li>匹配失败时的回退原理  </li><li>时间复杂度解释</li></ul><p>系统地解析了这套算法的全流程。</p><p>如果你已经能写出 next 数组，那么你已经掌握了 KMP 的核心思想！</p><hr>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
      <tag>字符串匹配</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python 底层】heapq 深度解析：数据结构设计、源码细节与高阶用法</title>
    <link href="/2025/12/02/python-heapq-deep-dive/"/>
    <url>/2025/12/02/python-heapq-deep-dive/</url>
    
    <content type="html"><![CDATA[<h1 id="📘-前言：为什么要深入理解-heapq？"><a href="#📘-前言：为什么要深入理解-heapq？" class="headerlink" title="📘 前言：为什么要深入理解 heapq？"></a>📘 前言：为什么要深入理解 <code>heapq</code>？</h1><p>在 Python 里，只要涉及到下面这些关键词：</p><ul><li>✅ <strong>Top K 问题</strong>（前 K 大 &#x2F; 前 K 小）</li><li>✅ <strong>优先队列</strong> &#x2F; 任务调度</li><li>✅ <strong>流式数据中的最值维护</strong></li><li>✅ <strong>合并多路有序序列</strong></li></ul><p>基本上都会绕不过一个模块：<code>heapq</code>。</p><p>很多人对它的印象停留在两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>heapq.heappush(heap, x)<br>heapq.heappop(heap)<br></code></pre></td></tr></table></figure><p>但如果你想：</p><ul><li>写出<strong>性能更稳、复杂度更清楚</strong>的代码</li><li>更灵活地组合堆结构解决工程问题</li><li>在面试中展示对 Python 底层的理解</li></ul><p>那就值得系统地拆一拆：<strong><code>heapq</code> 背后到底是怎样一个数据结构，它的源码是怎么实现的，它有哪些容易踩坑和高阶用法。</strong></p><p>本文从<strong>数据结构设计 → CPython 源码逻辑 → 常用模式与复杂度分析</strong>给出一篇技术文章。</p><hr><h1 id="🧱-一、heapq-的本质：基于数组实现的二叉最小堆"><a href="#🧱-一、heapq-的本质：基于数组实现的二叉最小堆" class="headerlink" title="🧱 一、heapq 的本质：基于数组实现的二叉最小堆"></a>🧱 一、heapq 的本质：基于数组实现的二叉最小堆</h1><h2 id="1-1-不是“树结构”，而是“数组-逻辑上的完全二叉树”"><a href="#1-1-不是“树结构”，而是“数组-逻辑上的完全二叉树”" class="headerlink" title="1.1 不是“树结构”，而是“数组 + 逻辑上的完全二叉树”"></a>1.1 不是“树结构”，而是“数组 + 逻辑上的完全二叉树”</h2><p><code>heapq</code> 实现的是一个 <strong>二叉最小堆（binary min-heap）</strong>：</p><blockquote><ul><li>逻辑结构：完全二叉树  </li><li>存储结构：<strong>用 Python <code>list</code> 存储</strong>  </li><li>堆序性质：任意一个节点的值 <strong>不大于</strong> 其子节点的值（最小堆）</li></ul></blockquote><p>也就是说，你看到的是一个 <code>list</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heap = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>但 <code>heapq</code> 会把它<strong>解释为一个树</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">        1<br>    /       \<br>   3         5<br> /   \     /  \<br>7     9   8   (空)<br></code></pre></td></tr></table></figure><h2 id="1-2-数组索引与树节点的映射关系"><a href="#1-2-数组索引与树节点的映射关系" class="headerlink" title="1.2 数组索引与树节点的映射关系"></a>1.2 数组索引与树节点的映射关系</h2><p>对于数组索引 <code>i</code>（从 0 开始）：</p><ul><li>左孩子：<code>left(i)  = 2 * i + 1</code></li><li>右孩子：<code>right(i) = 2 * i + 2</code></li><li>父节点：<code>parent(i) = (i - 1) // 2</code></li></ul><p>用一个简单例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">heap = [h0, h1, h2, h3, h4, h5, h6, ...]<br>index:  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span>   <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ul><li><code>h0</code> 是根节点</li><li><code>h1</code> 和 <code>h2</code> 是 <code>h0</code> 的两个孩子（<code>1 = 2*0+1</code>, <code>2 = 2*0+2</code>）</li><li><code>h3</code>、<code>h4</code> 是 <code>h1</code> 的孩子（<code>3 = 2*1+1</code>, <code>4 = 2*1+2</code>）</li><li><code>h5</code>、<code>h6</code> 是 <code>h2</code> 的孩子（<code>5 = 2*2+1</code>, <code>6 = 2*2+2</code>）</li></ul><p><strong>注意：</strong></p><ul><li><code>heapq</code> 不会为你维护额外的“树结构对象”，本质上就是直接在 <code>list</code> 上做索引计算。</li><li>这也是它复杂度稳定、实现相对简单的原因之一。</li></ul><hr><h1 id="🧬-二、源码结构概览：heapq-是纯-Python-实现"><a href="#🧬-二、源码结构概览：heapq-是纯-Python-实现" class="headerlink" title="🧬 二、源码结构概览：heapq 是纯 Python 实现"></a>🧬 二、源码结构概览：heapq 是纯 Python 实现</h1><p>在 CPython 源码里，<code>heapq</code> 是一个纯 Python 模块（<code>Lib/heapq.py</code>），核心接口包括：</p><ul><li>基础堆操作：<ul><li><code>heappush(heap, item)</code></li><li><code>heappop(heap)</code></li><li><code>heapify(x)</code></li><li><code>heapreplace(heap, item)</code></li><li><code>heappushpop(heap, item)</code></li></ul></li><li>高阶功能：<ul><li><code>nlargest(n, iterable, key=None)</code></li><li><code>nsmallest(n, iterable, key=None)</code></li><li><code>merge(*iterables, key=None, reverse=False)</code></li></ul></li></ul><p>内部实现中，有两个“私有”辅助函数非常关键：</p><ul><li><code>_siftdown(heap, startpos, pos)</code>：从上往下调整（插入时使用）</li><li><code>_siftup(heap, pos)</code>：从下往上调整（弹出堆顶后使用）</li></ul><p>接下来我们就按“堆的生命周期”顺序来拆解这些函数：构建堆、插入、删除、替换。</p><hr><h1 id="⚙️-三、heappush：从底向上“冒泡”的插入操作"><a href="#⚙️-三、heappush：从底向上“冒泡”的插入操作" class="headerlink" title="⚙️ 三、heappush：从底向上“冒泡”的插入操作"></a>⚙️ 三、<code>heappush</code>：从底向上“冒泡”的插入操作</h1><h2 id="3-1-heappush-的接口设计"><a href="#3-1-heappush-的接口设计" class="headerlink" title="3.1 heappush 的接口设计"></a>3.1 heappush 的接口设计</h2><p><code>heappush</code> 的函数签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappush(heap, item)<br></code></pre></td></tr></table></figure><p>含义：</p><blockquote><p>把 <code>item</code> 按规则插入到堆 <code>heap</code> 中，同时维护堆的最小堆性质。</p></blockquote><p>使用前后，要求你保证：</p><ul><li>插入前：<code>heap</code> 已经是合法的最小堆</li><li>插入后：<code>heap</code> 仍然是合法的最小堆</li></ul><h2 id="3-2-heappush-的源码逻辑（简化版本）"><a href="#3-2-heappush-的源码逻辑（简化版本）" class="headerlink" title="3.2 heappush 的源码逻辑（简化版本）"></a>3.2 heappush 的源码逻辑（简化版本）</h2><p>源码逻辑（简化伪代码）大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heappush</span>(<span class="hljs-params">heap, item</span>):<br>    heap.append(item)          <span class="hljs-comment"># 1. 先把新元素放到数组末尾</span><br>    _siftdown(heap, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heap) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2. 再通过上浮调整堆序</span><br></code></pre></td></tr></table></figure><p>核心操作是 <code>_siftdown</code>，它的作用是：</p><blockquote><p>让新插入的节点从当前位置 <code>pos</code> 向上（朝根方向）比较父节点，如果比父节点小则交换，一直上浮到合适的位置。</p></blockquote><h2 id="3-3-siftdown-的具体行为"><a href="#3-3-siftdown-的具体行为" class="headerlink" title="3.3 _siftdown 的具体行为"></a>3.3 <code>_siftdown</code> 的具体行为</h2><p>（以下为简化后的伪代码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_siftdown</span>(<span class="hljs-params">heap, startpos, pos</span>):<br>    newitem = heap[pos]<br>    <span class="hljs-comment"># 当未到达根节点，并且新元素比父节点小，则向上移动父节点</span><br>    <span class="hljs-keyword">while</span> pos &gt; startpos:<br>        parentpos = (pos - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span><br>        parent = heap[parentpos]<br>        <span class="hljs-keyword">if</span> newitem &lt; parent:<br>            heap[pos] = parent   <span class="hljs-comment"># 父节点下移</span><br>            pos = parentpos      <span class="hljs-comment"># 继续向上比较</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    heap[pos] = newitem          <span class="hljs-comment"># 在最终位置放入新元素</span><br></code></pre></td></tr></table></figure><p>这里可以看到几个关键点：</p><ol><li><p><strong>用二进制右移来算 parent 索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">parentpos = (pos - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>与 <code>// 2</code> 等价，但位运算在 C 层更快一些。</p></li><li><p><strong>比较逻辑只涉及 <code>&lt;</code></strong></p><p>因为 Python 的最小堆要求“父节点 ≤ 子节点”，插入时只要发现“新元素 &lt; 父节点”，就要把父节点下移。</p></li><li><p><strong>复杂度</strong></p><p>堆的高度为 <code>O(log n)</code>，最多比较并上浮 <code>O(log n)</code> 次，所以：</p><blockquote><p>插入一个元素：<strong><code>O(log n)</code></strong></p></blockquote></li></ol><hr><h1 id="🧊-四、heappop：弹出堆顶-从上到下的“下沉”"><a href="#🧊-四、heappop：弹出堆顶-从上到下的“下沉”" class="headerlink" title="🧊 四、heappop：弹出堆顶 + 从上到下的“下沉”"></a>🧊 四、<code>heappop</code>：弹出堆顶 + 从上到下的“下沉”</h1><h2 id="4-1-heappop-的接口定义"><a href="#4-1-heappop-的接口定义" class="headerlink" title="4.1 heappop 的接口定义"></a>4.1 heappop 的接口定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappop(heap) -&gt; item<br></code></pre></td></tr></table></figure><p>含义：</p><blockquote><p>弹出并返回堆中最小的元素（堆顶），同时维护堆序性质。</p></blockquote><p>前提条件：<code>heap</code> 必须是一个非空堆。</p><h2 id="4-2-heappop-的源码逻辑（伪代码）"><a href="#4-2-heappop-的源码逻辑（伪代码）" class="headerlink" title="4.2 heappop 的源码逻辑（伪代码）"></a>4.2 heappop 的源码逻辑（伪代码）</h2><p>简化后的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heappop</span>(<span class="hljs-params">heap</span>):<br>    lastelt = heap.pop()           <span class="hljs-comment"># 1. 取出最后一个元素</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> heap:<br>        <span class="hljs-keyword">return</span> lastelt             <span class="hljs-comment"># 堆只有一个元素时，直接返回</span><br>    returnitem = heap[<span class="hljs-number">0</span>]           <span class="hljs-comment"># 2. 记录堆顶（最小值）</span><br>    heap[<span class="hljs-number">0</span>] = lastelt              <span class="hljs-comment"># 3. 用最后一个元素补到堆顶</span><br>    _siftup(heap, <span class="hljs-number">0</span>)               <span class="hljs-comment"># 4. 从堆顶开始向下调整</span><br>    <span class="hljs-keyword">return</span> returnitem<br></code></pre></td></tr></table></figure><p>图形化理解：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">原堆:<br>        [1]<br>       /   \<br>     [3]   [5]<br>     / \   /<br>   [7] [9][8]<br><br>1) 弹出最后一个元素 8<br>2) 取出堆顶 1（结果）<br>3) 用 8 占据根：<br>        [8]<br>       /   \<br>     [3]   [5]<br>     / \   <br>   [7] [9]<br><br>4) 从根开始向下比较子节点，选择较小的子节点交换，直到恢复堆序<br></code></pre></td></tr></table></figure><h2 id="4-3-siftup-的执行过程"><a href="#4-3-siftup-的执行过程" class="headerlink" title="4.3 _siftup 的执行过程"></a>4.3 <code>_siftup</code> 的执行过程</h2><p>（简化伪代码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_siftup</span>(<span class="hljs-params">heap, pos</span>):<br>    endpos = <span class="hljs-built_in">len</span>(heap)<br>    newitem = heap[pos]<br>    childpos = <span class="hljs-number">2</span>*pos + <span class="hljs-number">1</span>      <span class="hljs-comment"># 左子节点索引</span><br>    <span class="hljs-keyword">while</span> childpos &lt; endpos:<br>        rightpos = childpos + <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 选择更小的那个子节点</span><br>        <span class="hljs-keyword">if</span> rightpos &lt; endpos <span class="hljs-keyword">and</span> heap[childpos] &gt; heap[rightpos]:<br>            childpos = rightpos<br>        <span class="hljs-comment"># 如果子节点比 newitem 小，子节点上移</span><br>        <span class="hljs-keyword">if</span> heap[childpos] &lt; newitem:<br>            heap[pos] = heap[childpos]<br>            pos = childpos<br>            childpos = <span class="hljs-number">2</span>*pos + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    heap[pos] = newitem<br></code></pre></td></tr></table></figure><p>要点：</p><ol><li>从根（或某个子树根）开始，把 <code>newitem</code> 当作一个“洞位”的填充值</li><li>一路向下与更小的子节点比较，维护堆序</li><li>最终在某一层“填入” <code>newitem</code></li></ol><p>这个过程同样只走堆高度的一条路径：</p><blockquote><p>弹出堆顶的复杂度：<strong><code>O(log n)</code></strong></p></blockquote><hr><h1 id="🧱-五、heapify：从无序数组线性构建堆"><a href="#🧱-五、heapify：从无序数组线性构建堆" class="headerlink" title="🧱 五、heapify：从无序数组线性构建堆"></a>🧱 五、<code>heapify</code>：从无序数组线性构建堆</h1><h2 id="5-1-接口与用途"><a href="#5-1-接口与用途" class="headerlink" title="5.1 接口与用途"></a>5.1 接口与用途</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heapify(x)<br></code></pre></td></tr></table></figure><p>含义：</p><blockquote><p>将任意的 <code>list x</code> 原地“堆化”成一个最小堆。</p></blockquote><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>a = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>heapq.heapify(a)<br><span class="hljs-comment"># a 变成了一个合法的最小堆（列表内部顺序会改变）</span><br></code></pre></td></tr></table></figure><h2 id="5-2-为什么复杂度是-O-n-，而不是-O-n-log-n-？"><a href="#5-2-为什么复杂度是-O-n-，而不是-O-n-log-n-？" class="headerlink" title="5.2 为什么复杂度是 O(n)，而不是 O(n log n)？"></a>5.2 为什么复杂度是 O(n)，而不是 O(n log n)？</h2><p><strong>直觉错误版本：</strong></p><blockquote><p>如果我们从空堆开始，一次一次 <code>heappush</code> 插入 n 个元素，复杂度是 <code>O(n log n)</code>。</p></blockquote><p><strong>但 heapify 并不是这么做的。</strong></p><p><code>heapq.heapify</code> 使用的是经典的 <strong>Floyd 堆构建算法</strong>：</p><ol><li>从最后一个非叶子节点开始，逆序地对每个节点执行 <code>siftup</code></li><li>每个节点“下沉”的期望高度远小于整个树的高度</li><li>算法的总体复杂度可以证明为 <strong>O(n)</strong></li></ol><h2 id="5-3-heapify-的简化伪代码"><a href="#5-3-heapify-的简化伪代码" class="headerlink" title="5.3 heapify 的简化伪代码"></a>5.3 heapify 的简化伪代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">x</span>):<br>    n = <span class="hljs-built_in">len</span>(x)<br>    <span class="hljs-comment"># 从最后一个非叶子节点开始，逐个向前调整</span><br>    <span class="hljs-comment"># 最后一个非叶子节点索引为 (n // 2 - 1)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(n // <span class="hljs-number">2</span>)):<br>        _siftup(x, i)<br></code></pre></td></tr></table></figure><p><strong>直观理解：</strong></p><ul><li>叶子节点本身就是合法的堆（只有一个元素）</li><li>从叶子上一层开始，对每个节点做“向下调整”</li><li>自底向上的好处是：每个节点调整的代价不高，整体代价是线性的</li></ul><hr><h1 id="🧮-六、heapq-提供的高级接口：nlargest、nsmallest、merge"><a href="#🧮-六、heapq-提供的高级接口：nlargest、nsmallest、merge" class="headerlink" title="🧮 六、heapq 提供的高级接口：nlargest、nsmallest、merge"></a>🧮 六、heapq 提供的高级接口：<code>nlargest</code>、<code>nsmallest</code>、<code>merge</code></h1><h2 id="6-1-nlargest-nsmallest-的内部策略"><a href="#6-1-nlargest-nsmallest-的内部策略" class="headerlink" title="6.1 nlargest &#x2F; nsmallest 的内部策略"></a>6.1 <code>nlargest</code> &#x2F; <code>nsmallest</code> 的内部策略</h2><p>接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.nlargest(n, iterable, key=<span class="hljs-literal">None</span>)<br>heapq.nsmallest(n, iterable, key=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>这两个函数内部其实是 <strong>“根据 n 的大小选择策略”</strong>：</p><ul><li>当 <code>n</code> 较小：使用堆（类似我们写的 Top-K 堆解法）→ <code>O(len(iterable) log n)</code></li><li>当 <code>n</code> 接近于总大小时：直接 <code>sorted(iterable)</code> 再切片 → <code>O(len(iterable) log len(iterable))</code></li></ul><p>大致行为可以概括为（伪代码思路）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> []<br><span class="hljs-keyword">if</span> n &gt;= <span class="hljs-built_in">len</span>(data):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(data, reverse=...)[:n]<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 使用堆算法</span><br></code></pre></td></tr></table></figure><p>所以在使用时，你可以把它理解为：</p><blockquote><p><strong>“自动根据 n 大小帮你选堆 or 排序的 Top-K 工具函数”</strong></p></blockquote><hr><h2 id="6-2-merge：多路归并的堆实现"><a href="#6-2-merge：多路归并的堆实现" class="headerlink" title="6.2 merge：多路归并的堆实现"></a>6.2 <code>merge</code>：多路归并的堆实现</h2><p>接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.merge(*iterables, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>用途：</p><blockquote><p>合并多个<strong>已排序序列</strong>，返回一个懒序列（迭代器），按整体排序顺序产生元素。</p></blockquote><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]<br>b = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]<br>c = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>]<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> heapq.merge(a, b, c):<br>    <span class="hljs-built_in">print</span>(x, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 输出：1 2 3 4 5 6 7 8 9</span><br></code></pre></td></tr></table></figure><p>内部实现思路：</p><ul><li>对每个可迭代对象取出第一个元素，放入堆中，堆元素形式一般为 <code>(值, 来自哪个迭代器, 迭代器本身或其 next 函数)</code></li><li>每次 <code>heappop</code> 取出全体中的最小值，然后从对应的那个迭代器中拿下一个元素入堆</li><li>复杂度类似<strong>多路归并排序</strong>中的归并阶段：如果有 <code>k</code> 路，总代价近似 <code>O(N log k)</code>（N 是总元素数）</li></ul><hr><h1 id="🧩-七、Python-中基于-heapq-的常见模式"><a href="#🧩-七、Python-中基于-heapq-的常见模式" class="headerlink" title="🧩 七、Python 中基于 heapq 的常见模式"></a>🧩 七、Python 中基于 heapq 的常见模式</h1><h2 id="7-1-实现一个最小优先队列"><a href="#7-1-实现一个最小优先队列" class="headerlink" title="7.1 实现一个最小优先队列"></a>7.1 实现一个最小优先队列</h2><p>典型用法：存储 <code>(优先级, 数据)</code> 元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>pq = []<br>heapq.heappush(pq, (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;process B&quot;</span>))<br>heapq.heappush(pq, (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;process A&quot;</span>))<br>heapq.heappush(pq, (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;process C&quot;</span>))<br><br><span class="hljs-keyword">while</span> pq:<br>    priority, task = heapq.heappop(pq)<br>    <span class="hljs-built_in">print</span>(priority, task)<br></code></pre></td></tr></table></figure><p>输出顺序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1 process A<br>2 process B<br>3 process C<br></code></pre></td></tr></table></figure><p>要点：</p><ul><li><p>堆总是按“元组的第一个元素”排序</p></li><li><p>当优先级相同时，可以借助一个递增的“序号”保证稳定性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">counter = <span class="hljs-number">0</span><br>heapq.heappush(pq, (priority, counter, task))<br>counter += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-2-用负数模拟最大堆（Max-Heap）"><a href="#7-2-用负数模拟最大堆（Max-Heap）" class="headerlink" title="7.2 用负数模拟最大堆（Max-Heap）"></a>7.2 用负数模拟最大堆（Max-Heap）</h2><p><code>heapq</code> 只提供最小堆，如果你想要最大堆，有两个常见技巧：</p><h3 id="写法一：取负数作为“优先级”"><a href="#写法一：取负数作为“优先级”" class="headerlink" title="写法一：取负数作为“优先级”"></a>写法一：取负数作为“优先级”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>max_heap = []<br>nums = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>    heapq.heappush(max_heap, (-x, x))  <span class="hljs-comment"># (-值, 值)</span><br><br><span class="hljs-keyword">while</span> max_heap:<br>    _, x = heapq.heappop(max_heap)<br>    <span class="hljs-built_in">print</span>(x, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 输出：9 5 3 1</span><br></code></pre></td></tr></table></figure><ul><li>堆按 <code>-x</code> 升序 &#x3D; 按 <code>x</code> 降序</li><li>适合 Top-K 最大值等场景</li></ul><h3 id="写法二：手动封装一个-MaxHeap-类（本质还是负数）"><a href="#写法二：手动封装一个-MaxHeap-类（本质还是负数）" class="headerlink" title="写法二：手动封装一个 MaxHeap 类（本质还是负数）"></a>写法二：手动封装一个 MaxHeap 类（本质还是负数）</h3><p>可以基于负数封装一个干净的接口，不在业务代码里到处写负号。</p><hr><h2 id="7-3-Top-K-问题：固定大小的小顶堆"><a href="#7-3-Top-K-问题：固定大小的小顶堆" class="headerlink" title="7.3 Top-K 问题：固定大小的小顶堆"></a>7.3 Top-K 问题：固定大小的小顶堆</h2><p>你前面写的“前 K 个高频元素”就是这一模式的标准范例：</p><ul><li>用哈希表统计频率</li><li>用<strong>大小为 k 的小顶堆</strong>维护目前的 top-k 元素</li><li>遍历完后，堆中剩下的就是答案</li></ul><p>同样的模式可以用于：</p><ul><li>Top-K 最大值 &#x2F; 最小值</li><li>实时数据流中维护“当前窗口的前 K 大&#x2F;小”</li></ul><hr><h2 id="7-4-合并-K-个有序列表（手写版）"><a href="#7-4-合并-K-个有序列表（手写版）" class="headerlink" title="7.4 合并 K 个有序列表（手写版）"></a>7.4 合并 K 个有序列表（手写版）</h2><p>虽然有 <code>heapq.merge</code>，但实际代码中很多人会手写一个 K 路归并的堆逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_k_sorted_lists</span>(<span class="hljs-params">arrs</span>):<br>    heap = []<br>    <span class="hljs-comment"># 初始化，把每个列表的第一个元素压入堆</span><br>    <span class="hljs-keyword">for</span> i, arr <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arrs):<br>        <span class="hljs-keyword">if</span> arr:<br>            heapq.heappush(heap, (arr[<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span>))  <span class="hljs-comment"># (值, 属于第 i 个数组, 该数组中的索引)</span><br><br>    result = []<br>    <span class="hljs-keyword">while</span> heap:<br>        val, arr_idx, idx_in_arr = heapq.heappop(heap)<br>        result.append(val)<br>        next_idx = idx_in_arr + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> next_idx &lt; <span class="hljs-built_in">len</span>(arrs[arr_idx]):<br>            heapq.heappush(heap, (arrs[arr_idx][next_idx], arr_idx, next_idx))<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>这个模式在：</p><ul><li>大数据离线排序</li><li>多文件归并</li><li>K 路流合并</li></ul><p>中都非常常见。</p><hr><h1 id="⏱-八、时间复杂度与操作对比总结"><a href="#⏱-八、时间复杂度与操作对比总结" class="headerlink" title="⏱ 八、时间复杂度与操作对比总结"></a>⏱ 八、时间复杂度与操作对比总结</h1><p>最后用一张表总结 <code>heapq</code> 常用操作的复杂度（n 为堆大小，k 为 Top-K 中的 K）：</p><table><thead><tr><th>操作</th><th>描述</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>heappush</code></td><td>插入一个元素</td><td><code>O(log n)</code></td></tr><tr><td><code>heappop</code></td><td>弹出最小元素</td><td><code>O(log n)</code></td></tr><tr><td><code>heapreplace</code></td><td><code>heappop</code> 后再 <code>heappush</code></td><td><code>O(log n)</code></td></tr><tr><td><code>heappushpop</code></td><td><code>heappush</code> 后再 <code>heappop</code></td><td><code>O(log n)</code>（略优）</td></tr><tr><td><code>heapify</code></td><td>从无序列表构建堆</td><td><code>O(n)</code></td></tr><tr><td>Top-K（堆方式）</td><td>维护大小为 k 的堆</td><td><code>O(n log k)</code></td></tr><tr><td><code>nlargest</code>&#x2F;<code>nsmallest</code></td><td>Top-K 工具函数</td><td><code>O(n log k)</code> 或 <code>O(n log n)</code></td></tr><tr><td><code>merge</code></td><td>多路有序归并</td><td><code>O(N log k)</code></td></tr></tbody></table><hr><h1 id="✅-九、总结：理解-heapq，掌握的是一整类“优先级问题”的解法"><a href="#✅-九、总结：理解-heapq，掌握的是一整类“优先级问题”的解法" class="headerlink" title="✅ 九、总结：理解 heapq，掌握的是一整类“优先级问题”的解法"></a>✅ 九、总结：理解 heapq，掌握的是一整类“优先级问题”的解法</h1><p>通过深入理解 <code>heapq</code> 的底层设计和源码细节，你不仅可以：</p><ul><li>正确、稳定地使用堆解决各类 Top-K &#x2F; 优先队列问题</li><li>写出复杂度明确、行为可控的算法代码</li><li>在面试中清晰讲明 <strong>“为什么是 O(log n)”、为什么 heapify 是 O(n)</strong></li></ul><p>更重要的是：</p><blockquote><p>你会自然而然地把“堆”当成日常工具箱的一部分，<br>一旦遇到“我只关心最小&#x2F;最大&#x2F;前 K 个”的问题，就会第一时间想到它。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PythonInvestigate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python底层</tag>
      
      <tag>heapq</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>TopK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】单调队列彻底搞懂滑动窗口最大值（Python 详解）</title>
    <link href="/2025/12/02/max-sliding-window/"/>
    <url>/2025/12/02/max-sliding-window/</url>
    
    <content type="html"><![CDATA[<h1 id="📘-滑动窗口最大值：用单调队列实现-O-n-的优雅解法"><a href="#📘-滑动窗口最大值：用单调队列实现-O-n-的优雅解法" class="headerlink" title="📘 滑动窗口最大值：用单调队列实现 O(n) 的优雅解法"></a>📘 滑动窗口最大值：用<strong>单调队列</strong>实现 O(n) 的优雅解法</h1><p>滑动窗口最大值（Sliding Window Maximum）是一道非常经典且高频的算法题。<br>朴素解法时间复杂度高达 <strong>O(n·k)</strong>，而使用 <strong>单调队列（Monotonic Queue）</strong> 后，可以优化到 <strong>O(n)</strong>。</p><p>这篇文章将带你：</p><ul><li>彻底理解单调队列的作用</li><li>清楚掌握元素为何能“自动淘汰”</li><li>明白窗口滑动与队列维护之间的关系</li><li>通过精美排版，看懂每一行代码背后的含义</li></ul><hr><h1 id="🌟-一、问题回顾：为什么需要单调队列？"><a href="#🌟-一、问题回顾：为什么需要单调队列？" class="headerlink" title="🌟 一、问题回顾：为什么需要单调队列？"></a>🌟 一、问题回顾：为什么需要单调队列？</h1><p>给定数组 <code>nums</code> 和窗口大小 <code>k</code>：</p><blockquote><p>每次窗口滑动一步，返回窗口中的最大值。</p></blockquote><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">nums = <span class="hljs-string">[1,3,-1,-3,5,3,6,7]</span><br>k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,3,5,5,6,7]</span><br></code></pre></td></tr></table></figure><p>如果每次都扫描窗口求最大值，那就是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">O</span><span class="hljs-params">(n * k)</span></span> → 超时<br></code></pre></td></tr></table></figure><p>单调队列提供了一种巧妙的方法，把时间复杂度降到 <strong>O(n)</strong>。</p><hr><h1 id="🌈-二、单调队列是什么？"><a href="#🌈-二、单调队列是什么？" class="headerlink" title="🌈 二、单调队列是什么？"></a>🌈 二、单调队列是什么？</h1><p>单调队列（Monotonic Queue）是一种特殊队列，满足：</p><ul><li><strong>队列从左到右递减</strong></li><li>队头永远是当前窗口的最大值</li><li>新元素加入时，会把所有比它小的“无用元素”全部弹出</li></ul><p><strong>为什么可以弹出？</strong><br>因为：如果新元素更大，那么旧的小元素永远不可能成为最大值。</p><hr><h1 id="🧠-三、核心操作：加入新元素-update-kept-nums"><a href="#🧠-三、核心操作：加入新元素-update-kept-nums" class="headerlink" title="🧠 三、核心操作：加入新元素 update_kept_nums"></a>🧠 三、核心操作：加入新元素 <code>update_kept_nums</code></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_kept_nums</span>(<span class="hljs-params">kept_nums, num</span>):<br>    <span class="hljs-comment"># 移除所有比当前新元素小的尾部元素</span><br>    <span class="hljs-keyword">while</span> kept_nums <span class="hljs-keyword">and</span> num &gt; kept_nums[-<span class="hljs-number">1</span>]:<br>        kept_nums.pop()<br>    kept_nums.append(num)<br></code></pre></td></tr></table></figure><h3 id="🔍-为什么要这样做？来看例子："><a href="#🔍-为什么要这样做？来看例子：" class="headerlink" title="🔍 为什么要这样做？来看例子："></a>🔍 为什么要这样做？来看例子：</h3><p>加入序列：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 3, 2, 5]</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>队列变化</th><th>解释</th></tr></thead><tbody><tr><td>push 1</td><td>[1]</td><td>队列为空直接加入</td></tr><tr><td>push 3</td><td>[3]</td><td>3 &gt; 1 → 弹出 1</td></tr><tr><td>push 2</td><td>[3,2]</td><td>2 &lt; 3 → 不弹</td></tr><tr><td>push 5</td><td>[5]</td><td>5 &gt; 2 → 弹；5 &gt; 3 → 弹</td></tr></tbody></table><p>队列永远保持“从大到小”。<br>这些剩下的元素都是“未来有可能成为最大值的候选”。</p><hr><h1 id="📌-四、窗口滑动：旧值如何退出？"><a href="#📌-四、窗口滑动：旧值如何退出？" class="headerlink" title="📌 四、窗口滑动：旧值如何退出？"></a>📌 四、窗口滑动：旧值如何退出？</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> i &gt;= k <span class="hljs-keyword">and</span> nums[i - k] == kept_nums[<span class="hljs-number">0</span>]:<br>    kept_nums.popleft()<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>i - k</code> 表示<strong>窗口最左边即将移出的元素</strong></li><li>如果这个元素等于队头，那么它失效了 → 必须弹出</li></ul><p><strong>如果不是队头？</strong></p><p>不需要处理，因为队头仍是最大值。</p><hr><h1 id="🧩-五、完整代码解析（最清晰版本）"><a href="#🧩-五、完整代码解析（最清晰版本）" class="headerlink" title="🧩 五、完整代码解析（最清晰版本）"></a>🧩 五、完整代码解析（最清晰版本）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        max_list = []              <span class="hljs-comment"># 存放结果</span><br>        kept_nums = deque()        <span class="hljs-comment"># 单调队列（从大到小）</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 将新元素加入单调队列</span><br>            update_kept_nums(kept_nums, nums[i])<br><br>            <span class="hljs-comment"># 如果窗口已经开始滑动，旧元素要检查是否需要出队</span><br>            <span class="hljs-keyword">if</span> i &gt;= k <span class="hljs-keyword">and</span> nums[i - k] == kept_nums[<span class="hljs-number">0</span>]:<br>                kept_nums.popleft()<br><br>            <span class="hljs-comment"># 当窗口大小达到 k 时，记录最大值</span><br>            <span class="hljs-keyword">if</span> i &gt;= k - <span class="hljs-number">1</span>:<br>                max_list.append(kept_nums[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">return</span> max_list<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_kept_nums</span>(<span class="hljs-params">kept_nums, num</span>):<br>    <span class="hljs-comment"># 所有小于新元素的队尾值都没有意义，直接删除</span><br>    <span class="hljs-keyword">while</span> kept_nums <span class="hljs-keyword">and</span> num &gt; kept_nums[-<span class="hljs-number">1</span>]:<br>        kept_nums.pop()<br>    kept_nums.append(num)<br></code></pre></td></tr></table></figure><hr><h1 id="🔥-六、运行过程可视化（关键！）"><a href="#🔥-六、运行过程可视化（关键！）" class="headerlink" title="🔥 六、运行过程可视化（关键！）"></a>🔥 六、运行过程可视化（关键！）</h1><p>以 nums &#x3D; <code>[1,3,-1,-3,5,3,6,7]</code>，k &#x3D; 3 为例：</p><table><thead><tr><th>i</th><th>当前元素</th><th>单调队列（大 → 小）</th><th>当前最大值</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>[1]</td><td>-</td></tr><tr><td>1</td><td>3</td><td>[3]</td><td>-</td></tr><tr><td>2</td><td>-1</td><td>[3, -1]</td><td><strong>3</strong></td></tr><tr><td>3</td><td>-3</td><td>[3, -1, -3]</td><td><strong>3</strong></td></tr><tr><td>4</td><td>5</td><td>[5]</td><td><strong>5</strong></td></tr><tr><td>5</td><td>3</td><td>[5,3]</td><td><strong>5</strong></td></tr><tr><td>6</td><td>6</td><td>[6]</td><td><strong>6</strong></td></tr><tr><td>7</td><td>7</td><td>[7]</td><td><strong>7</strong></td></tr></tbody></table><hr><h1 id="🏁-七、总结：单调队列的优势"><a href="#🏁-七、总结：单调队列的优势" class="headerlink" title="🏁 七、总结：单调队列的优势"></a>🏁 七、总结：单调队列的优势</h1><p>单调队列清晰、高效，是解决滑动窗口最大值问题的最优数据结构：</p><h3 id="✔-每个元素最多进队一次"><a href="#✔-每个元素最多进队一次" class="headerlink" title="✔ 每个元素最多进队一次"></a>✔ 每个元素最多进队一次</h3><h3 id="✔-每个元素最多出队一次"><a href="#✔-每个元素最多出队一次" class="headerlink" title="✔ 每个元素最多出队一次"></a>✔ 每个元素最多出队一次</h3><h3 id="✔-总时间复杂度-O-n"><a href="#✔-总时间复杂度-O-n" class="headerlink" title="✔ 总时间复杂度 O(n)"></a>✔ 总时间复杂度 O(n)</h3><h3 id="✔-空间复杂度-O-k"><a href="#✔-空间复杂度-O-k" class="headerlink" title="✔ 空间复杂度 O(k)"></a>✔ 空间复杂度 O(k)</h3><p>掌握单调队列之后，你就能轻松应对：</p><ul><li>滑动窗口最大&#x2F;最小值  </li><li>股票价格趋势分析  </li><li>区间内动态最大值或最小值查询</li></ul><p>等一大类算法问题。</p><hr>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>单调队列</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】Top K 高频元素三大解法：Counter、堆、桶排序一次讲透</title>
    <link href="/2025/12/02/top-k-frequent-elements-heap-counter-bucket/"/>
    <url>/2025/12/02/top-k-frequent-elements-heap-counter-bucket/</url>
    
    <content type="html"><![CDATA[<h1 id="📘-前言：一道题吃透三种思路"><a href="#📘-前言：一道题吃透三种思路" class="headerlink" title="📘 前言：一道题吃透三种思路"></a>📘 前言：一道题吃透三种思路</h1><p>在算法题中，“<strong>前 K 个高频元素</strong>”（Top K Frequent Elements）是一个非常经典的题目，也是各种面试和刷题平台（比如 LeetCode 347）的常客。</p><blockquote><p>题目简化版描述：<br>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请返回出现频率前 <code>k</code> 高的元素。</p></blockquote><p>这道题<strong>看似简单，实则是 Top-K 问题的入门模板</strong>。<br>根据不同的约束条件和工程场景，我们可以设计出不同解法：</p><ul><li>✅ 用 <code>Counter.most_common</code> 一行解决——简单直接，适合写脚本</li><li>✅ 用 <strong>小顶堆（min-heap）</strong> 将复杂度优化到 <code>O(n log k)</code>，适合大数据场景</li><li>✅ 用 <strong>桶排序（Bucket Sort）</strong> 在特定条件下做到接近 <code>O(n)</code>，适合频率分布可控的情况</li></ul><p>本文会围绕你给出的这段<strong>小顶堆实现代码</strong>，系统性地设计一篇技术博客，并顺带把另外两种主流解法也讲透。</p><hr><h1 id="🧩-一、问题定义与样例"><a href="#🧩-一、问题定义与样例" class="headerlink" title="🧩 一、问题定义与样例"></a>🧩 一、问题定义与样例</h1><p>我们先用一个具体例子统一语境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>k = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>期望输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 元素 1 出现 3 次，元素 2 出现 2 次，是出现频率最高的两个</span><br></code></pre></td></tr></table></figure><p>更一般地，这道题可以抽象为：</p><blockquote><p>给定长度为 <code>n</code> 的数组，设不同元素个数为 <code>m</code>，找出频率最高的 <code>k</code> 个元素。<br>其中 <code>1 &lt;= k &lt;= m &lt;= n</code>。</p></blockquote><hr><h1 id="🧠-二、解法总览：三种主流思路对比"><a href="#🧠-二、解法总览：三种主流思路对比" class="headerlink" title="🧠 二、解法总览：三种主流思路对比"></a>🧠 二、解法总览：三种主流思路对比</h1><p>我们先从宏观上看三种典型解法：  </p><table><thead><tr><th>解法</th><th>核心数据结构</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>Counter + 排序</td><td>哈希表 + 排序</td><td><code>O(n log n)</code></td><td><code>O(n)</code></td><td>n 不大、代码简洁优先</td></tr><tr><td>小顶堆（min-heap）</td><td>哈希表 + 大小为 k 堆</td><td><code>O(n log k)</code></td><td><code>O(n)</code></td><td>k 远小于 n，Top-K 通用套路</td></tr><tr><td>桶排序（Bucket Sort）</td><td>哈希表 + 频率桶</td><td>近似 <code>O(n)</code></td><td><code>O(n)</code></td><td>频率上界可控，追求极致复杂度时</td></tr></tbody></table><p>下面重点展开<strong>堆解法</strong>，然后扩展到 <strong>Counter.most_common</strong> 和 <strong>桶排序</strong>，形成一个完整的 Top-K 高频元素解法系列。</p><hr><h1 id="⚙️-三、解法一：Counter-most-common-——-一行代码的暴力优雅"><a href="#⚙️-三、解法一：Counter-most-common-——-一行代码的暴力优雅" class="headerlink" title="⚙️ 三、解法一：Counter.most_common —— 一行代码的暴力优雅"></a>⚙️ 三、解法一：Counter.most_common —— 一行代码的暴力优雅</h1><p>Python 标准库 <code>collections.Counter</code> 内置了一个非常适合这道题的方法：<code>most_common(k)</code>。</p><h3 id="✅-核心代码"><a href="#✅-核心代码" class="headerlink" title="✅ 核心代码"></a>✅ 核心代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        counter = Counter(nums)<br>        <span class="hljs-comment"># most_common(k) 返回 [(元素, 频率), ...] 按频率从高到低排序</span><br>        <span class="hljs-keyword">return</span> [num <span class="hljs-keyword">for</span> num, _ <span class="hljs-keyword">in</span> counter.most_common(k)]<br></code></pre></td></tr></table></figure><h3 id="⏱-时间复杂度"><a href="#⏱-时间复杂度" class="headerlink" title="⏱ 时间复杂度"></a>⏱ 时间复杂度</h3><ul><li>建立 <code>Counter</code>：遍历一遍数组，<code>O(n)</code></li><li><code>most_common(k)</code> 内部会根据频率排序，复杂度为 <code>O(m log m)</code>（m 是不同元素的个数，最坏 <code>m ≈ n</code>）</li></ul><p>总体复杂度接近：<strong><code>O(n log n)</code></strong>。</p><h3 id="👍-优点"><a href="#👍-优点" class="headerlink" title="👍 优点"></a>👍 优点</h3><ul><li>代码极简、可读性非常高</li><li>对 Python 熟悉的人一眼就懂</li><li>非常适合脚本、小数据、刷题时快速通过</li></ul><h3 id="👎-缺点"><a href="#👎-缺点" class="headerlink" title="👎 缺点"></a>👎 缺点</h3><ul><li>排序是全局排序，哪怕只要前 k 个，也要对所有元素排完整的序</li><li>当 n 很大、k 很小的时候，性能不够“极致”</li></ul><p>这时，就轮到小顶堆方案出场了。</p><hr><h1 id="🧱-四、解法二：小顶堆（Min-Heap），Top-K-问题的通用解法"><a href="#🧱-四、解法二：小顶堆（Min-Heap），Top-K-问题的通用解法" class="headerlink" title="🧱 四、解法二：小顶堆（Min-Heap），Top-K 问题的通用解法"></a>🧱 四、解法二：小顶堆（Min-Heap），Top-K 问题的通用解法</h1><p>下面是给出的堆解法代码，我做了少量变量名美化，让语义更清晰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 时间复杂度：O(n log k)</span><br><span class="hljs-comment"># 空间复杂度：O(n)</span><br><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 1. 统计每个元素的出现频率</span><br>        freq_map = &#123;&#125;  <span class="hljs-comment"># key: 元素值, value: 出现次数</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            freq_map[x] = freq_map.get(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 2. 用一个大小为 k 的小顶堆，维护当前最高频的 k 个元素</span><br>        min_heap = []  <span class="hljs-comment"># 堆元素形式为 (freq, num)</span><br><br>        <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> freq_map.items():<br>            heapq.heappush(min_heap, (freq, num))<br>            <span class="hljs-comment"># 如果堆的大小超过了 k，就弹出堆顶（频率最小的那个）</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(min_heap) &gt; k:<br>                heapq.heappop(min_heap)<br><br>        <span class="hljs-comment"># 3. 此时堆中剩下的就是前 k 个高频元素，但顺序是由小到大的</span><br>        result = [<span class="hljs-number">0</span>] * k<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># heappop 每次弹出最小的频率，所以倒着填入结果</span><br>            result[i] = heapq.heappop(min_heap)[<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>接下来我们从底层逻辑到细节实现，全程拆解。</p><hr><h2 id="4-1-频率统计：freq-map-的构建"><a href="#4-1-频率统计：freq-map-的构建" class="headerlink" title="4.1 频率统计：freq_map 的构建"></a>4.1 频率统计：freq_map 的构建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">freq_map = &#123;&#125;<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>    freq_map[x] = freq_map.get(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这一步：</p><ul><li>本质是用哈希表统计频率：<code>元素值 → 出现次数</code></li><li><code>dict.get(key, default)</code> 让我们可以用一行实现“如果不存在就从 0 开始计数”</li></ul><p>示例：<code>nums = [1, 1, 1, 2, 2, 3]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">freq_map = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(m)</code>，m 是不同元素个数。</p><hr><h2 id="4-2-为什么用小顶堆？堆里为什么存-freq-num-？"><a href="#4-2-为什么用小顶堆？堆里为什么存-freq-num-？" class="headerlink" title="4.2 为什么用小顶堆？堆里为什么存 (freq, num)？"></a>4.2 为什么用小顶堆？堆里为什么存 <code>(freq, num)</code>？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">min_heap = []<br><br><span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> freq_map.items():<br>    heapq.heappush(min_heap, (freq, num))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(min_heap) &gt; k:<br>        heapq.heappop(min_heap)<br></code></pre></td></tr></table></figure><p>这里有三个关键问题：</p><h3 id="❓-1）为什么用堆，而不是再次排序？"><a href="#❓-1）为什么用堆，而不是再次排序？" class="headerlink" title="❓ 1）为什么用堆，而不是再次排序？"></a>❓ 1）为什么用堆，而不是再次排序？</h3><ul><li>排序复杂度是 <code>O(m log m)</code>，即使只要前 k 个，也要排完整的序</li><li>堆可以实现“<strong>随时知道 top-k 集合中最差的那一个</strong>”，并及时淘汰</li></ul><p>整体复杂度可以降为：<strong><code>O(m log k)</code></strong><br>当 <code>k &lt;&lt; m</code> 时，非常划算。</p><hr><h3 id="❓-2）为什么是小顶堆，而不是大顶堆？"><a href="#❓-2）为什么是小顶堆，而不是大顶堆？" class="headerlink" title="❓ 2）为什么是小顶堆，而不是大顶堆？"></a>❓ 2）为什么是小顶堆，而不是大顶堆？</h3><p>在 Top-K 问题中，常见套路是：</p><blockquote><p>“用一个<strong>大小为 k</strong>的小顶堆维护当前的前 k 大元素。”</p></blockquote><p>堆顶元素是当前 top-k 中最小的那个，一旦来了一个更大的，就可以把堆顶“淘汰”掉。</p><p>在这道题中，“大”和“小”的比较维度是：<strong>频率大小</strong>。</p><hr><h3 id="❓-3）为什么堆元素是-freq-num-而不是-num-freq-？"><a href="#❓-3）为什么堆元素是-freq-num-而不是-num-freq-？" class="headerlink" title="❓ 3）为什么堆元素是 (freq, num) 而不是 (num, freq)？"></a>❓ 3）为什么堆元素是 <code>(freq, num)</code> 而不是 <code>(num, freq)</code>？</h3><p>Python 的 <code>heapq</code> 会把堆中的元素看作“可以比较的对象”。<br>比较规则对于元组 <code>(a1, b1)</code> 与 <code>(a2, b2)</code>：</p><ol><li>先比较 <code>a1</code> 和 <code>a2</code></li><li>如果相等，再比较 <code>b1</code> 和 <code>b2</code></li></ol><p>所以，把元组写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(freq, num)<br></code></pre></td></tr></table></figure><p>就可以保证 <strong>堆是按频率 <code>freq</code> 从小到大排序的</strong>，堆顶一定是频率最小的那个元素（在当前堆中）。</p><hr><h2 id="4-3-通过“push-条件-pop”维持堆大小为-k"><a href="#4-3-通过“push-条件-pop”维持堆大小为-k" class="headerlink" title="4.3 通过“push + 条件 pop”维持堆大小为 k"></a>4.3 通过“push + 条件 pop”维持堆大小为 k</h2><p>这一段逻辑非常关键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappush(min_heap, (freq, num))<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(min_heap) &gt; k:<br>    heapq.heappop(min_heap)<br></code></pre></td></tr></table></figure><p>语义是：</p><blockquote><p>先把当前 <code>(freq, num)</code> 当成“候选 top-k”扔进堆，<br>如果堆里元素超过 k 个了，说明有一个多余的，就把频率最小的那个弹出去。</p></blockquote><p>这就确保了：</p><ul><li>堆中始终保存“当前遇到过的元素中，频率最高的 k 个”</li><li>只要遍历完所有元素后，堆中留下的就是答案集合</li></ul><hr><h2 id="4-4-堆内容演示：一步一步模拟"><a href="#4-4-堆内容演示：一步一步模拟" class="headerlink" title="4.4 堆内容演示：一步一步模拟"></a>4.4 堆内容演示：一步一步模拟</h2><p>以 <code>freq_map = {1: 3, 2: 2, 3: 1}, k = 2</code> 为例：</p><p>1️⃣ 处理 <code>(1, 3)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">push (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)  →  heap = [(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-built_in">len</span> = <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>  → 不弹出<br></code></pre></td></tr></table></figure><p>2️⃣ 处理 <code>(2, 2)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">push (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)  →  heap = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-built_in">len</span> = <span class="hljs-number">2</span> == <span class="hljs-number">2</span> → 不弹出<br></code></pre></td></tr></table></figure><p>3️⃣ 处理 <code>(3, 1)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">push (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)  →  heap = [(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)]   <span class="hljs-comment"># 堆顶是 (1, 3)</span><br><span class="hljs-built_in">len</span> = <span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>  →  pop() 弹出 (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br>最终 heap = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]<br></code></pre></td></tr></table></figure><p>堆中保存的是两个元素：</p><ul><li><code>(2, 2)</code>：数字 2 出现 2 次</li><li><code>(3, 1)</code>：数字 1 出现 3 次</li></ul><p>这正是我们想要的答案集合。</p><hr><h2 id="4-5-为何结果要“倒序填充”？"><a href="#4-5-为何结果要“倒序填充”？" class="headerlink" title="4.5 为何结果要“倒序填充”？"></a>4.5 为何结果要“倒序填充”？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result = [<span class="hljs-number">0</span>] * k<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>    result[i] = heapq.heappop(min_heap)[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>heappop</code> 每次弹出的都是堆中<strong>最小的频率</strong></li><li>也就是说，第一个弹出的，其实是 top-k 里面“最弱”的那个元素</li></ul><p>因此：</p><ul><li>如果我们希望 <code>result</code> 里从高频到低频排列，就需要<strong>从后往前填</strong></li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">heap = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]   <span class="hljs-comment"># 按频率从小到大</span><br>k = <span class="hljs-number">2</span><br><br>i = <span class="hljs-number">1</span>:<br>    pop → (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) → result[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>i = <span class="hljs-number">0</span>:<br>    pop → (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) → result[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>result = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>这就是最终输出。</p><hr><h2 id="4-6-复杂度总结"><a href="#4-6-复杂度总结" class="headerlink" title="4.6 复杂度总结"></a>4.6 复杂度总结</h2><ul><li>统计频率：<code>O(n)</code></li><li>遍历 <code>freq_map</code>（至多 m 个不同元素）：<ul><li>每个执行一次 <code>heappush</code>：<code>O(log k)</code></li><li>部分执行 <code>heappop</code>：<code>O(log k)</code></li></ul></li><li>总体复杂度：<strong><code>O(n log k)</code></strong></li></ul><p>空间复杂度：</p><ul><li><code>freq_map</code>：最多 <code>O(n)</code></li><li><code>min_heap</code>：最多 <code>O(k)</code></li><li>总体为：<strong><code>O(n)</code></strong></li></ul><hr><h1 id="🪣-五、解法三：桶排序（Bucket-Sort）——-利用“频率有限”的特性"><a href="#🪣-五、解法三：桶排序（Bucket-Sort）——-利用“频率有限”的特性" class="headerlink" title="🪣 五、解法三：桶排序（Bucket Sort）—— 利用“频率有限”的特性"></a>🪣 五、解法三：桶排序（Bucket Sort）—— 利用“频率有限”的特性</h1><p>Top-K 高频元素还有一种非常有趣并且复杂度很优的解法：<strong>桶排序</strong>。</p><p>核心想法：</p><blockquote><p>元素的频率最多是 <code>n</code>（数组长度），<br>那么可以创建 <code>n+1</code> 个“桶”，第 i 个桶存所有出现了 i 次的元素。</p></blockquote><h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol><li>还是先用 <code>freq_map</code> 或 <code>Counter</code> 统计所有元素频率</li><li>创建一个长度为 <code>len(nums) + 1</code> 的桶数组 <code>buckets</code>，其中每个桶是一个列表</li><li>遍历 <code>freq_map</code>，把元素按频率放入对应的桶：<ul><li>频率为 <code>f</code> 的元素放入 <code>buckets[f]</code></li></ul></li><li>从后往前遍历桶（从高频到低频），依次取出桶中的元素，直到收集到 k 个为止</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        counter = Counter(nums)<br>        n = <span class="hljs-built_in">len</span>(nums)<br><br>        <span class="hljs-comment"># 第 i 个桶，存所有出现频率为 i 的元素</span><br>        buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> counter.items():<br>            buckets[freq].append(num)<br><br>        result = []<br>        <span class="hljs-comment"># 从频率最高的桶开始向前遍历</span><br>        <span class="hljs-keyword">for</span> freq <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> buckets[freq]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> buckets[freq]:<br>                result.append(num)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) == k:<br>                    <span class="hljs-keyword">return</span> result<br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>构造 Counter：<code>O(n)</code></li><li>填充桶：<code>O(m)</code>，m 为不同元素个数（最坏 <code>m ≈ n</code>）</li><li>遍历桶：每个元素最多访问一次 → <code>O(n)</code></li></ul><p>整体上，可以认为是：<strong><code>O(n)</code> 时间复杂度，<code>O(n)</code> 空间复杂度</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>理论上的时间复杂度非常优秀</li><li>在频率分布比较均匀、数据大的场景下，表现不错</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要额外分配 <code>O(n)</code> 数组作为桶</li><li>对 Python 初学者不如堆方案直观</li><li>在工程中可维护性略差一点（相对堆 + Counter）</li></ul><hr><h1 id="🧮-六、三种解法对比：从“刷题”到“工程实践”"><a href="#🧮-六、三种解法对比：从“刷题”到“工程实践”" class="headerlink" title="🧮 六、三种解法对比：从“刷题”到“工程实践”"></a>🧮 六、三种解法对比：从“刷题”到“工程实践”</h1><p>下面把三种解法放在一起做个统一对比：</p><table><thead><tr><th>解法</th><th>复杂度</th><th>代码复杂度</th><th>适合场景</th></tr></thead><tbody><tr><td>Counter.most_common</td><td>时间 <code>O(n log n)</code>，空间 <code>O(n)</code></td><td>⭐ 最简单</td><td>数据量一般、快速写题、脚本工具</td></tr><tr><td>小顶堆（min-heap）</td><td>时间 <code>O(n log k)</code>，空间 <code>O(n)</code></td><td>⭐⭐ 中等</td><td>Top-K 通用解法、k 远小于 n 的情况</td></tr><tr><td>桶排序（Bucket Sort）</td><td>时间 ≈ <code>O(n)</code>，空间 <code>O(n)</code></td><td>⭐⭐⭐ 稍复杂</td><td>理论复杂度要求高、频率范围受限时</td></tr></tbody></table><ul><li>想写得“简洁可读”：✅ 用 <code>Counter.most_common</code></li><li>想展示数据结构功底：✅ 用 <strong>小顶堆</strong>（优先队列）</li><li>想展示“对复杂度有追求的算法选手”：✅ 再补一份桶排序版本</li></ul><hr><h1 id="✅-七、总结：真正掌握的是“模式”，不是某一道题"><a href="#✅-七、总结：真正掌握的是“模式”，不是某一道题" class="headerlink" title="✅ 七、总结：真正掌握的是“模式”，不是某一道题"></a>✅ 七、总结：真正掌握的是“模式”，不是某一道题</h1><p>通过这一道“Top K 高频元素”：</p><p>你实际上掌握了三个非常通用的套路：</p><ol><li><strong>哈希表 + 排序</strong>：适用于很多“统计 + 排序”的题</li><li><strong>哈希表 + 小顶堆（固定大小 k）</strong>：几乎所有 Top-K 问题都能套用</li><li><strong>哈希表 + 桶排序</strong>：当“值域 &#x2F; 频率上界有限”时的一种常见优化</li></ol><p>堆代码，正好是其中**最具有“工程感”和“可扩展性”**的一种写法，非常值得深入吃透 在实际工程中使用</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>TopK</tag>
      
      <tag>Python</tag>
      
      <tag>频率统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python 底层】deque 源码深度解析：数据结构设计、实现原理与性能优势</title>
    <link href="/2025/12/02/python-deque-deep-dive/"/>
    <url>/2025/12/02/python-deque-deep-dive/</url>
    
    <content type="html"><![CDATA[<h1 id="📘-前言：为什么要研究-collections-deque？"><a href="#📘-前言：为什么要研究-collections-deque？" class="headerlink" title="📘 前言：为什么要研究 collections.deque？"></a>📘 前言：为什么要研究 <code>collections.deque</code>？</h1><p>在 Python 中，<strong><code>collections.deque</code> 是一个非常高效的双端队列（double-ended queue）容器</strong>。它被广泛用于：</p><ul><li>BFS &#x2F; 图遍历 的队列</li><li>滑动窗口最大值 &#x2F; 最小值（单调队列）</li><li>日志缓冲、固定长度缓存</li><li>生产者-消费者模型</li></ul><p>相比之下，很多人只知道：</p><ul><li><code>list.append()</code> 很快  </li><li>但 <code>list.insert(0, x)</code> 和 <code>list.pop(0)</code> 很慢</li></ul><p>于是会被建议：</p><blockquote><p>“要用队列就用 <code>deque</code>。”</p></blockquote><p>那 <strong><code>deque</code> 到底比 <code>list</code> 高级在哪？</strong><br>它是不是链表？是动态数组？还是其他什么结构？</p><p>这篇文章会从 <strong>CPython 源码实现</strong> 出发，深入剖析 <code>deque</code> 的底层结构与设计思想，让你真正理解：</p><ul><li><code>deque</code> 背后用的是什么数据结构？</li><li>为什么它头尾操作是 O(1)，但随机访问却很慢？</li><li>它如何在“数组”和“链表”的优点之间做到平衡？</li></ul><hr><h1 id="🧱-一、deque-的真实身份：分段数组-双向链表"><a href="#🧱-一、deque-的真实身份：分段数组-双向链表" class="headerlink" title="🧱 一、deque 的真实身份：分段数组 + 双向链表"></a>🧱 一、deque 的真实身份：分段数组 + 双向链表</h1><p>很多人以为：</p><ul><li><code>deque</code> 是一个“双向链表”</li><li>或者是“可变大小的 list”</li></ul><p>其实都不准确。</p><p>在 CPython 的实现里（<code>Objects/dequeobject.c</code>），<code>deque</code> 的核心结构可以概括为：</p><blockquote><p><strong>“由多个固定大小的数组块（block）构成的双向链表”</strong></p></blockquote><p>用更形象的方式看，就是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[ block(-2) ] &lt;--&gt; [ block(-1) ] &lt;--&gt; [ block(0) ] &lt;--&gt; [ block(+1) ] &lt;--&gt; [ block(+2) ]<br></code></pre></td></tr></table></figure><ul><li>每个 <code>block</code> 是一个<strong>固定长度</strong>的数组（例如 64 个槽位）</li><li>所有 <code>block</code> 通过双向链表相连</li><li>队列两端的元素，位于最左侧和最右侧的 block 上</li></ul><p>这样，<code>deque</code> 既具备：</p><ul><li>数组的 <strong>局部连续性</strong>（block 内）</li><li>链表的 <strong>全局可扩展性</strong></li></ul><p>是一种 <strong>混合结构</strong>，专门为“高效双端操作”而设计。</p><hr><h1 id="🧬-二、源码结构：block-与-dequeobject"><a href="#🧬-二、源码结构：block-与-dequeobject" class="headerlink" title="🧬 二、源码结构：block 与 dequeobject"></a>🧬 二、源码结构：block 与 dequeobject</h1><p>在 CPython 源码中（略化简），<code>deque</code> 底层大致定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCKLEN 64  <span class="hljs-comment">// 每个 block 的固定长度（不同版本可能略有差异）</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block</span> *<span class="hljs-title">leftlink</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block</span> *<span class="hljs-title">rightlink</span>;</span><br>    PyObject *data[BLOCKLEN];<br>&#125; block;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_HEAD<br>    block *leftblock;   <span class="hljs-comment">// 当前最左侧 block</span><br>    block *rightblock;  <span class="hljs-comment">// 当前最右侧 block</span><br>    Py_ssize_t leftindex;<br>    Py_ssize_t rightindex;<br>    Py_ssize_t len;     <span class="hljs-comment">// 当前 deque 中元素个数</span><br>&#125; dequeobject;<br></code></pre></td></tr></table></figure><p>👉 关键字段解释：</p><ul><li><p><code>block</code>：  </p><ul><li>一个 <strong>固定长度的数组</strong>，用来存放一段连续的元素  </li><li><code>leftlink</code> &#x2F; <code>rightlink</code> 把多个 block 串成一个双向链表</li></ul></li><li><p><code>leftblock</code> &#x2F; <code>rightblock</code>：  </p><ul><li>指向双端队列的左右“端点”所在的 block</li></ul></li><li><p><code>leftindex</code> &#x2F; <code>rightindex</code>：  </p><ul><li>分别记录左端和右端元素在对应 block 内部数组中的索引位置</li></ul></li><li><p><code>len</code>：  </p><ul><li>当前队列总长度（方便 O(1) 获取 <code>len(d)</code>）</li></ul></li></ul><p>可以把 deque 想象为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">            leftblock                       rightblock<br>┌─────────────────────┐    ┌─────────────────────┐<br>│ [-,-,-, 1, 2, 3]    │&lt;--&gt;| [4, 5, 6,-,-,-]     │<br>└─────────────────────┘    └─────────────────────┘<br>              ↑ leftindex              ↑ rightindex<br></code></pre></td></tr></table></figure><hr><h1 id="⚙️-三、为什么-append-appendleft-是-O-1-？"><a href="#⚙️-三、为什么-append-appendleft-是-O-1-？" class="headerlink" title="⚙️ 三、为什么 append &#x2F; appendleft 是 O(1)？"></a>⚙️ 三、为什么 append &#x2F; appendleft 是 O(1)？</h1><p>以 <code>append(x)</code> 为例（右端入队）：</p><p>伪代码逻辑大致是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (rightblock 已满) &#123;<br>    分配一个新的 block;<br>    让 old_rightblock-&gt;rightlink = new_block;<br>    让 new_block-&gt;leftlink = old_rightblock;<br>    更新 <span class="hljs-built_in">deque</span>-&gt;rightblock = new_block;<br>    将 rightindex 重置为新 block 的起始位置;<br>&#125;<br>在 rightblock-&gt;data[rightindex] 写入 x，并递增 rightindex &amp; len。<br></code></pre></td></tr></table></figure><p>特点是：</p><ul><li><strong>绝大多数情况下，只在当前 block 上操作，完全 O(1)</strong>  </li><li>当 block 写满时，<strong>只分配一个新的 block 并挂到链表末尾，也是 O(1)</strong>  </li><li>不存在像 list 那样“一次性搬迁一大块连续内存”的情况</li></ul><p>同理，<code>appendleft(x)</code> 在左端进行类似逻辑：</p><ul><li>如果 <code>leftblock</code> 还有空位：直接写入  </li><li>如果 <code>leftblock</code> 满了：分配一个新的 block 挂在左侧</li></ul><p>所以：</p><blockquote><p>✅ “头尾插入 &#x2F; 删除” 对于 deque 来说，始终是 <strong>严格意义上的 O(1)</strong> 操作。</p></blockquote><p>对比 <code>list</code>：</p><ul><li><code>list.append()</code> 虽然摊还 O(1)，但扩容时需要整体搬迁  </li><li><code>list.insert(0, x)</code> 和 <code>list.pop(0)</code> 是 <strong>O(n)</strong>（需要移动所有后续元素）</li></ul><hr><h1 id="🧊-四、pop-popleft-的执行逻辑"><a href="#🧊-四、pop-popleft-的执行逻辑" class="headerlink" title="🧊 四、pop &#x2F; popleft 的执行逻辑"></a>🧊 四、pop &#x2F; popleft 的执行逻辑</h1><p><code>pop()</code>（右端弹出）：</p><ol><li>从 <code>rightblock-&gt;data[rightindex]</code> 取出元素，设置为 <code>NULL</code></li><li><code>rightindex--</code>，<code>len--</code></li><li>如果该 block 元素全部被弹空，则：<ul><li>释放该 block</li><li>将 <code>rightblock</code> 移到左侧的 block</li></ul></li></ol><p><code>popleft()</code>（左端弹出）同理，只是操作的是 <code>leftblock</code> 和 <code>leftindex</code>。</p><p>由于每次只改变一个 block 中的少量内容：</p><blockquote><p>✅ 所以这两个操作也都是 O(1)。</p></blockquote><hr><h1 id="🚫-五、为什么-deque-不适合做随机访问？"><a href="#🚫-五、为什么-deque-不适合做随机访问？" class="headerlink" title="🚫 五、为什么 deque 不适合做随机访问？"></a>🚫 五、为什么 deque 不适合做随机访问？</h1><p>你可以写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>d = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>d[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 可以</span><br>d[<span class="hljs-number">3</span>]   <span class="hljs-comment"># 也可以</span><br></code></pre></td></tr></table></figure><p>但要注意：</p><ul><li>访问 <code>d[i]</code> 的底层实现，是<strong>从 leftblock 开始，一个 block 一个 block 地往右走</strong></li><li>找到第 <code>i</code> 个元素所在的 block 及其内部索引</li></ul><p>因此：</p><ul><li>访问中间元素 <code>d[i]</code> 不是 O(1)，而是 <strong>O(块数)</strong>  </li><li>对大 deque、频繁随机访问时，性能明显不如 list</li></ul><p>结论：</p><blockquote><p><code>deque</code> 的设计目标是：<strong>优化两端操作</strong>，而不是随机访问。<br>如果你主要需求是随机访问和切片，应该优先考虑 <code>list</code>。</p></blockquote><hr><h1 id="📊-六、deque-vs-list：复杂度与用途对比"><a href="#📊-六、deque-vs-list：复杂度与用途对比" class="headerlink" title="📊 六、deque vs list：复杂度与用途对比"></a>📊 六、deque vs list：复杂度与用途对比</h1><p>下表总结了 <code>list</code> 与 <code>deque</code> 在常用操作上的复杂度差异：</p><table><thead><tr><th>操作</th><th><code>list</code></th><th><code>deque</code></th><th>典型用途</th></tr></thead><tbody><tr><td><code>append(x)</code></td><td>摊还 O(1)</td><td>O(1)</td><td>尾部插入</td></tr><tr><td><code>pop()</code></td><td>O(1)</td><td>O(1)</td><td>尾部删除</td></tr><tr><td><code>insert(0, x)</code></td><td>❌ O(n)</td><td>✅ O(1) (<code>appendleft</code>)</td><td>头部插入</td></tr><tr><td><code>pop(0)</code></td><td>❌ O(n)</td><td>✅ O(1) (<code>popleft</code>)</td><td>头部删除</td></tr><tr><td><code>d[i]</code> 随机访问</td><td>✅ O(1)</td><td>❌ O(k)（按 block 遍历）</td><td>频繁随机访问 → 用 list</td></tr><tr><td>内部存储</td><td>连续数组</td><td>分段数组 + 链表</td><td>内存模型不同</td></tr></tbody></table><p>一句话总结：</p><blockquote><p><strong>要做“栈 &#x2F; 队列 &#x2F; 双端队列” → 用 <code>deque</code></strong><br><strong>要做“随机访问、切片、大量索引” → 用 <code>list</code></strong></p></blockquote><hr><h1 id="🔍-七、一个简单的性能对比示例"><a href="#🔍-七、一个简单的性能对比示例" class="headerlink" title="🔍 七、一个简单的性能对比示例"></a>🔍 七、一个简单的性能对比示例</h1><p>下面用简单的代码，感受一下：<strong>用 list 和 deque 实现队列的性能差异</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_list_queue</span>(<span class="hljs-params">n</span>):<br>    q = []<br>    t = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        q.append(i)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        q.pop(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 头部弹出：O(n)</span><br>    <span class="hljs-keyword">return</span> time.time() - t<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_deque_queue</span>(<span class="hljs-params">n</span>):<br>    q = deque()<br>    t = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        q.append(i)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        q.popleft()  <span class="hljs-comment"># 头部弹出：O(1)</span><br>    <span class="hljs-keyword">return</span> time.time() - t<br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [<span class="hljs-number">10_000</span>, <span class="hljs-number">50_000</span>, <span class="hljs-number">100_000</span>]:<br>    t1 = time_list_queue(n)<br>    t2 = time_deque_queue(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n=<span class="hljs-subst">&#123;n:6d&#125;</span>  list pop(0): <span class="hljs-subst">&#123;t1:<span class="hljs-number">.4</span>f&#125;</span>s   deque popleft(): <span class="hljs-subst">&#123;t2:<span class="hljs-number">.4</span>f&#125;</span>s&quot;</span>)<br></code></pre></td></tr></table></figure><p>在大多数环境下，你会看到：</p><ul><li><code>list pop(0)</code> 随着 <code>n</code> 增大迅速变慢  </li><li><code>deque popleft()</code> 表现很稳定</li></ul><p>这印证了我们前面分析的复杂度差异。</p><hr><h1 id="🧩-八、block-结构示意图（形象理解）"><a href="#🧩-八、block-结构示意图（形象理解）" class="headerlink" title="🧩 八、block 结构示意图（形象理解）"></a>🧩 八、block 结构示意图（形象理解）</h1><p>再用一张图把 deque 的内部结构直观呈现出来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">   leftblock                                 rightblock<br>┌────────────────┐    ┌────────────────┐    ┌────────────────┐<br>│ [-,-, 7, 8, 9] │&lt;--&gt;| [10,11,12,13]  │&lt;--&gt;| [14,15,-,-,-]  │<br>└────────────────┘    └────────────────┘    └────────────────┘<br>        ↑ leftindex                          ↑ rightindex<br></code></pre></td></tr></table></figure><ul><li>左端元素从 <code>leftblock</code> 的 <code>leftindex</code> 处“生长 &#x2F; 收缩”</li><li>右端元素从 <code>rightblock</code> 的 <code>rightindex</code> 处“生长 &#x2F; 收缩”</li><li>中间的 block 存储完整填充的数据</li><li>当某一侧的 block 被完全弹空，会被释放掉，指针指向下一个 block</li></ul><p>这种结构，在<strong>频繁头尾操作</strong>的场景下，比“单个巨大连续数组”的 list 更节省内存搬迁成本。</p><hr><h1 id="✅-九、总结：你应该何时选-deque？"><a href="#✅-九、总结：你应该何时选-deque？" class="headerlink" title="✅ 九、总结：你应该何时选 deque？"></a>✅ 九、总结：你应该何时选 deque？</h1><p><strong>非常适合用 deque 的场景：</strong></p><ul><li>需要大量 <code>append</code> &#x2F; <code>appendleft</code> &#x2F; <code>pop</code> &#x2F; <code>popleft</code></li><li>典型 <strong>队列（queue）&#x2F; 双端队列（deque）</strong> 场景</li><li>滑动窗口、单调队列（如 LeetCode 239）</li><li>BFS、层次遍历、任务调度队列</li><li>固定长度缓存：<code>deque(maxlen=1000)</code></li></ul><p><strong>不适合用 deque 的场景：</strong></p><ul><li>需要频繁按下标访问：<code>d[i]</code></li><li>需要大量切片操作：<code>d[10:100]</code></li><li>更偏向“数组语义”而非“队列语义”</li></ul><hr><h1 id="🎯-结尾"><a href="#🎯-结尾" class="headerlink" title="🎯 结尾"></a>🎯 结尾</h1><blockquote><p><code>deque</code> 是为“队列 &amp; 双端操作”高度优化的容器，<br>它的底层结构比 list 更复杂，但也更优雅。<br>理解它的实现原理，会大幅提升你对 <strong>数据结构与性能</strong> 的直觉。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PythonInvestigate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python底层</tag>
      
      <tag>数据结构</tag>
      
      <tag>deque</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
